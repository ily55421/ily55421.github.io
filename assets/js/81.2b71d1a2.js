(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{679:function(a,s,n){"use strict";n.r(s);var v=n(0),e=Object(v.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"_03-java虚拟机是如何加载java类的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_03-java虚拟机是如何加载java类的"}},[a._v("#")]),a._v(" 03 | Java虚拟机是如何加载Java类的?")]),a._v(" "),s("p",[a._v("听我的意大利同事说，他们那边有个习俗，就是父亲要帮儿子盖栋房子。")]),a._v(" "),s("p",[a._v("这事要放在以前还挺简单，亲朋好友搭把手，盖个小砖房就可以住人了。现在呢，整个过程要耗费好久的时间。首先你要请建筑师出个方案，然后去市政部门报备、验证，通过后才可以开始盖房子。盖好房子还要装修，之后才能住人。")]),a._v(" "),s("p",[a._v("盖房子这个事，和 Java 虚拟机中的类加载还是挺像的。从 class  文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。那么，是否所有的 Java 类都需要经过这几步呢？")]),a._v(" "),s("p",[a._v("我们知道 Java 语言的类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。在上一篇中，我已经详细介绍过了 Java 的基本类型，它们是由 Java 虚拟机预先定义好的。")]),a._v(" "),s("p",[a._v("至于另一大类引用类型，Java 将其细分为四种：类、接口、数组类和泛型参数。由于泛型参数会在编译过程中被擦除（我会在专栏的第二部分详细介绍），因此 Java  虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。")]),a._v(" "),s("p",[a._v("说到字节流，最常见的形式要属由 Java 编译器生成的 class 文件。除此之外，我们也可以在程序内部直接生成，或者从网络中获取（例如网页中内嵌的小程序 Java  applet）字节流。这些不同形式的字节流，都会被加载到 Java 虚拟机中，成为类或接口。为了叙述方便，下面我就用“类”来统称它们。")]),a._v(" "),s("p",[a._v("无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。接下来，我会详细给你介绍一下每个步骤具体都在干些什么。")]),a._v(" "),s("h2",{attrs:{id:"加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加载"}},[a._v("#")]),a._v(" 加载")]),a._v(" "),s("p",[a._v("加载，是指查找字节流，并且据此创建类的过程。前面提到，对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。")]),a._v(" "),s("p",[a._v("以盖房子为例，村里的 Tony 要盖个房子，那么按照流程他得先找个建筑师，跟他说想要设计一个房型，比如说“一房、一厅、四卫”。你或许已经听出来了，这里的房型相当于类，而建筑师，就相当于类加载器。")]),a._v(" "),s("p",[a._v("村里有许多建筑师，他们等级森严，但有着共同的祖师爷，叫启动类加载器（bootstrap class loader）。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null  来指代。换句话说，祖师爷不喜欢像 Tony 这样的小角色来打扰他，所以谁也没有祖师爷的联系方式。")]),a._v(" "),s("p",[a._v("除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。")]),a._v(" "),s("p",[a._v("村里的建筑师有一个潜规则，就是接到单子自己不能着手干，得先给师傅过过目。师傅不接手的情况下，才能自己来。在 Java  虚拟机中，这个潜规则有个特别的名字，叫双亲委派模型。每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。")]),a._v(" "),s("p",[a._v("在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数  -Xbootclasspath 指定的类）。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器（extension class  loader）和应用类加载器（application class loader），均由 Java 核心类库提供。")]),a._v(" "),s("p",[a._v("扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。")]),a._v(" "),s("p",[a._v("应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH  所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。")]),a._v(" "),s("p",[a._v("Java 9 引入了模块系统，并且略微更改了上述的类加载器"),s("a",{attrs:{href:"https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-A868D0B9-026F-4D46-B979-901834343F9E",target:"_blank",rel:"noopener noreferrer"}},[a._v("1"),s("OutboundLink")],1),a._v("。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。")]),a._v(" "),s("p",[a._v("除了由 Java 核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊的加载方式。举例来说，我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。")]),a._v(" "),s("p",[a._v("除了加载功能之外，类加载器还提供了命名空间的作用。这个很好理解，打个比方，咱们这个村不讲究版权，如果你剽窃了另一个建筑师的设计作品，那么只要你标上自己的名字，这两个房型就是不同的。")]),a._v(" "),s("p",[a._v("在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。")]),a._v(" "),s("h2",{attrs:{id:"链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链接"}},[a._v("#")]),a._v(" 链接")]),a._v(" "),s("p",[a._v("链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。")]),a._v(" "),s("p",[a._v("验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。这就好比 Tony 需要将设计好的房型提交给市政部门审核。只有当审核通过，才能继续下面的建造工作。")]),a._v(" "),s("p",[a._v("通常而言，Java 编译器生成的类文件必然满足 Java 虚拟机的约束条件。因此，这部分我留到讲解字节码注入时再详细介绍。")]),a._v(" "),s("p",[a._v("准备阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。过了这个阶段，咱们算是盖好了毛坯房。虽然结构已经完整，但是在没有装修之前是不能住人的。")]),a._v(" "),s("p",[a._v("除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。")]),a._v(" "),s("p",[a._v("在 class 文件被加载至 Java  虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java  编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。")]),a._v(" "),s("p",[a._v("举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。")]),a._v(" "),s("p",[a._v("解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）")]),a._v(" "),s("p",[a._v("如果将这段话放在盖房子的语境下，那么符号引用就好比“Tony 的房子”这种说法，不管它存在不存在，我们都可以用这种说法来指代 Tony 的房子。实际引用则好比实际的通讯地址，如果我们想要与 Tony 通信，则需要启动盖房子的过程。")]),a._v(" "),s("p",[a._v("Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。")]),a._v(" "),s("h2",{attrs:{id:"初始化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[a._v("#")]),a._v(" 初始化")]),a._v(" "),s("p",[a._v("在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。")]),a._v(" "),s("p",[a._v("如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java  编译器标记成常量值（ConstantValue），其初始化直接由 Java  虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 < clinit  >。")]),a._v(" "),s("p",[a._v("类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。Java 虚拟机会通过加锁来确保类的 < clinit > 方法仅被执行一次。")]),a._v(" "),s("p",[a._v("只有当初始化完成之后，类才正式成为可执行的状态。这放在我们盖房子的例子中就是，只有当房子装修过后，Tony 才能真正地住进去。")]),a._v(" "),s("p",[a._v("那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：")]),a._v(" "),s("ol",[s("li",[a._v("当虚拟机启动时，初始化用户指定的主类；")]),a._v(" "),s("li",[a._v("当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；")]),a._v(" "),s("li",[a._v("当遇到调用静态方法的指令时，初始化该静态方法所在的类；")]),a._v(" "),s("li",[a._v("当遇到访问静态字段的指令时，初始化该静态字段所在的类；")]),a._v(" "),s("li",[a._v("子类的初始化会触发父类的初始化；")]),a._v(" "),s("li",[a._v("如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；")]),a._v(" "),s("li",[a._v("使用反射 API 对某个类进行反射调用时，初始化这个类；")]),a._v(" "),s("li",[a._v("当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\npublic class Singleton {\n\n  private Singleton() {}\n\n  private static class LazyHolder {\n\n    static final Singleton INSTANCE = new Singleton();\n\n  }\n\n  public static Singleton getInstance() {\n\n    return LazyHolder.INSTANCE;\n\n  }\n\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br")]),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br")])]),s("p",[a._v("我在文章中贴了一段代码，这段代码是在著名的单例延迟初始化例子中"),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom",target:"_blank",rel:"noopener noreferrer"}},[a._v("2"),s("OutboundLink")],1),a._v("，只有当调用 Singleton.getInstance 时，程序才会访问 LazyHolder.INSTANCE，才会触发对 LazyHolder 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例。")]),a._v(" "),s("p",[a._v("由于类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个 Singleton 实例。")]),a._v(" "),s("h2",{attrs:{id:"总结与实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结与实践"}},[a._v("#")]),a._v(" 总结与实践")]),a._v(" "),s("p",[a._v("今天我介绍了 Java 虚拟机将字节流转化为 Java 类的过程。这个过程可分为加载、链接以及初始化三大步骤。")]),a._v(" "),s("p",[a._v("加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。")]),a._v(" "),s("p",[a._v("链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。")]),a._v(" "),s("p",[a._v("初始化，则是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。")]),a._v(" "),s("p",[a._v("今天的实践环节，你可以来验证一下本篇中的理论知识。")]),a._v(" "),s("p",[a._v("通过 JVM 参数 -verbose:class 来打印类加载的先后顺序，并且在 LazyHolder 的初始化方法中打印特定字样。在命令行中运行下述指令（不包含提示符 $）：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('\n \n\n$ echo \'\n\npublic class Singleton {\n\n  private Singleton() {}\n\n  private static class LazyHolder {\n\n    static final Singleton INSTANCE = new Singleton();\n\n    static {\n\n      System.out.println("LazyHolder.<clinit>");\n\n    }\n\n  }\n\n  public static Object getInstance(boolean flag) {\n\n    if (flag) return new LazyHolder[2];\n\n    return LazyHolder.INSTANCE;\n\n  }\n\n  public static void main(String[] args) {\n\n    getInstance(true);\n\n    System.out.println("----");\n\n    getInstance(false);\n\n  }\n\n}\' > Singleton.java\n\n$ javac Singleton.java\n\n$ java -verbose:class Singleton\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br"),s("span",{staticClass:"line-number"},[a._v("30")]),s("br"),s("span",{staticClass:"line-number"},[a._v("31")]),s("br"),s("span",{staticClass:"line-number"},[a._v("32")]),s("br"),s("span",{staticClass:"line-number"},[a._v("33")]),s("br"),s("span",{staticClass:"line-number"},[a._v("34")]),s("br"),s("span",{staticClass:"line-number"},[a._v("35")]),s("br"),s("span",{staticClass:"line-number"},[a._v("36")]),s("br"),s("span",{staticClass:"line-number"},[a._v("37")]),s("br"),s("span",{staticClass:"line-number"},[a._v("38")]),s("br"),s("span",{staticClass:"line-number"},[a._v("39")]),s("br"),s("span",{staticClass:"line-number"},[a._v("40")]),s("br"),s("span",{staticClass:"line-number"},[a._v("41")]),s("br"),s("span",{staticClass:"line-number"},[a._v("42")]),s("br"),s("span",{staticClass:"line-number"},[a._v("43")]),s("br"),s("span",{staticClass:"line-number"},[a._v("44")]),s("br")]),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br"),s("span",{staticClass:"line-number"},[a._v("30")]),s("br"),s("span",{staticClass:"line-number"},[a._v("31")]),s("br"),s("span",{staticClass:"line-number"},[a._v("32")]),s("br"),s("span",{staticClass:"line-number"},[a._v("33")]),s("br"),s("span",{staticClass:"line-number"},[a._v("34")]),s("br"),s("span",{staticClass:"line-number"},[a._v("35")]),s("br"),s("span",{staticClass:"line-number"},[a._v("36")]),s("br"),s("span",{staticClass:"line-number"},[a._v("37")]),s("br"),s("span",{staticClass:"line-number"},[a._v("38")]),s("br"),s("span",{staticClass:"line-number"},[a._v("39")]),s("br"),s("span",{staticClass:"line-number"},[a._v("40")]),s("br"),s("span",{staticClass:"line-number"},[a._v("41")]),s("br"),s("span",{staticClass:"line-number"},[a._v("42")]),s("br"),s("span",{staticClass:"line-number"},[a._v("43")]),s("br"),s("span",{staticClass:"line-number"},[a._v("44")]),s("br")])]),s("p",[a._v("问题 1：新建数组（第 11 行）会导致 LazyHolder 的加载吗？会导致它的初始化吗？")]),a._v(" "),s("p",[a._v("在命令行中运行下述指令（不包含提示符 $）：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\n$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Singleton\\$LazyHolder.class > Singleton\\$LazyHolder.jasm.1\n\n$ awk 'NR==1,/stack 1/{sub(/stack 1/, \"stack 0\")} 1' Singleton\\$LazyHolder.jasm.1 > Singleton\\$LazyHolder.jasm\n\n$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Singleton\\$LazyHolder.jasm\n\n$ java -verbose:class Singleton\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br")]),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br")])]),s("p",[a._v("问题 2：新建数组会导致 LazyHolder 的链接吗？")]),a._v(" "),s("h2",{attrs:{id:"精选留言-100"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#精选留言-100"}},[a._v("#")]),a._v(" 精选留言(100)")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("东方")]),a._v(" "),s("p",[a._v("2018-07-25")]),a._v(" "),s("p",[a._v("49")]),a._v(" "),s("p",[a._v("\\1. 新建数组会加载元素类LazyHolder；不会初始化元素类")]),a._v(" "),s("p",[a._v("\\2. 新建数组不会链接元素类LazyHolder；在getInstance(false)时才真正链接和初始化\n-----------------\n链接的第一步：验证字节码，awk把字节码改为不符合jvm规范\n初始化调用"),s("clinit",[a._v("(即class init)")])],1),a._v(" "),s("p",[a._v("PS:好像二个问题包含了第一个问题的答案")]),a._v(" "),s("p",[a._v("作者回复: 多谢指出！")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("mover")]),a._v(" "),s("p",[a._v("2018-07-25")]),a._v(" "),s("p",[a._v("32")]),a._v(" "),s("p",[a._v("到目前为止，讲解的内容没有超出周志明老师的  深入理解JAVA虚拟机这本书的内容，老师可以讲解的更深入一点吗？可以介绍一下类加载后在meta区的大概布局吗？class类对象与meta区的类数据结构是什么关系？当我们创建类，使用类时，类实例，类对象，meta区类数据结构是如何交互的？")]),a._v(" "),s("p",[a._v("作者回复: 谢谢你的建议！前几章不好搞太难，希望后面能够满足你的需求")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("迈克擂")]),a._v(" "),s("p",[a._v("2018-07-29")]),a._v(" "),s("p",[a._v("23")]),a._v(" "),s("p",[a._v("学习了！可以的话希望老师能附上一些图解，便于更理解")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("慎独")]),a._v(" "),s("p",[a._v("2018-10-18")]),a._v(" "),s("p",[a._v("18")]),a._v(" "),s("p",[a._v("1.虚拟机必须知道（加载）有这个类，才能创建这个类的数组（容器），但是这个类并没有被使用到（没有达到初始化的条件），所以不会初始化。\n2.新建数组的时候并不是要使用这个类（只是定义了放这个类的容器），所以不会被链接，调用getInstance(false)的时候约等于告诉虚拟机，我要使用这个类了，你把这个类造好（链接），然后把static修饰的字符赋予变量（初始化）。\n老师看看理解对不对，指点一下。")]),a._v(" "),s("p",[a._v("作者回复: 对的！")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("ruyin")]),a._v(" "),s("p",[a._v("2018-07-27")]),a._v(" "),s("p",[a._v("14")]),a._v(" "),s("p",[a._v("-XX：+TraceClassLoading 可以看到类加载过程")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("conce2018")]),a._v(" "),s("p",[a._v("2018-09-25")]),a._v(" "),s("p",[a._v("9")]),a._v(" "),s("p",[a._v("为什么叫双亲委派呀，明明只给了父类加载应该是单亲呀")]),a._v(" "),s("p",[a._v("作者回复: 其实我也有这个疑问，英文中为parent不带s，照理应该翻译为单亲。但既然约定俗成翻译为双亲，就只好这样叫啦")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("仲伦")]),a._v(" "),s("p",[a._v("2018-07-27")]),a._v(" "),s("p",[a._v("8")]),a._v(" "),s("p",[a._v("忍着瞌睡把内容看完了。\n全是复习了一遍。\n作者对 类加载中的 链接(验证、准备、解析)讲解不太到位吧？\n另外，对一个的初始化发生在第一次主动使用该类时，作者列出的几种情况都属于主动使用类。感觉应该有被动使用的举例，并告知大家这样做是不会执行初始化的。")]),a._v(" "),s("p",[a._v("作者回复: 多谢建议！")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("小蛋壳")]),a._v(" "),s("p",[a._v("2018-07-26")]),a._v(" "),s("p",[a._v("6")]),a._v(" "),s("p",[a._v("加载阶段都加载哪些类呢，那么多类，全部加载吗？")]),a._v(" "),s("p",[a._v("作者回复: 加载阶段是针对单个类的，一般用到的类才会被加载。大部分情况下，不同类的加载阶段是不同的。")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("吴天")]),a._v(" "),s("p",[a._v("2018-07-25")]),a._v(" "),s("p",[a._v("6")]),a._v(" "),s("p",[a._v("每次new一个类都是一次初始化吧？加载和链接以后生成的是什么样的数据结构？存储在什么地方？")]),a._v(" "),s("p",[a._v("作者回复: 类的初始化只会发生一次，你可能指的是实例的初始化？")]),a._v(" "),s("p",[a._v("JVM并不会直接使用.class文件，类加载链接的目的就是在JVM中创建相应的类结构，会存储在元空间(我之前用的老说法”方法区”，感谢某同学指出)。")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("Geek_ecc6a...")]),a._v(" "),s("p",[a._v("2018-07-25")]),a._v(" "),s("p",[a._v("6")]),a._v(" "),s("p",[a._v("老师，你说可以通过不同的类加载器加载同一个类得到类的不同版本，我有个疑问，类是通过包名加类名来使用的，那怎么样区分不同的类加载器加载的类呢？")]),a._v(" "),s("p",[a._v("作者回复: 你指的是在写代码的时候如何区分对吧？我认为没法区分。如果你有一个类的两个不同版本，而且它们不兼容，那么编译时指向哪个，就按哪个来编译。也就是说，如果要同时使用两个版本，那么你需要分开编译。")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("scutware")]),a._v(" "),s("p",[a._v("2018-07-26")]),a._v(" "),s("p",[a._v("4")]),a._v(" "),s("p",[a._v("您在评论回复说.class在加载后已经写入方法区（元空间），但是我理解在方法区里类代码的方法调用应该是实际的调用地址吧？而取得实际调用地址不是在链接阶段吗？这里不太理解，求解答～")]),a._v(" "),s("p",[a._v("作者回复: 链接时取得的不是被加载类的地址，而且被加载类所调用的其它方法的地址")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("Geek_dde3a...")]),a._v(" "),s("p",[a._v("2018-07-25")]),a._v(" "),s("p",[a._v("4")]),a._v(" "),s("p",[a._v("请问有什么办法或者工具可以看到类加载的这些过程呢？")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("熊猫酒仙")]),a._v(" "),s("p",[a._v("2018-07-25")]),a._v(" "),s("p",[a._v("4")]),a._v(" "),s("p",[a._v("有几个疑问，请老师指点迷津。\n1.扩展类加载器的父类，是启动类加载器，而后者是C++实现的，java继承C++的类？不大能理解。\n2.虚方法的概念在C++中有了解过，java中的虚方法该如何定义呢？以前没接触过java虚方法的概念\n3.我以前的理解是，有一个零值(0/null)初始化，针对于类的静态成员变量，如果是final修饰的静态成员变量，也就是常量，是初始化为代码中指定的值比如10。非final修饰的静态成员变量，在clint执行过程中赋值为代码中指定的值，请问老师是这样的吗？")]),a._v(" "),s("p",[a._v("作者回复: 1. 可能我翻译得有点瑕疵，导致了你的误解。这里我指的是扩展器类的 父-类加载器，而不是父类-(加载器)。\n\\2. Java中所有的非私有实例方法，都算是虚方法。调用这些方法的指令，也区分直接调用和虚调用。下一篇我会讲到。\n\\3. 赞一个。被final修饰的静态成员变量，如果不是基本类型或者字符串，也会放在clinit 来做。")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("L.B.Q.Y")]),a._v(" "),s("p",[a._v("2018-07-25")]),a._v(" "),s("p",[a._v("4")]),a._v(" "),s("p",[a._v("从大的方面讲，类加载的结果是把一段字节流变换成Class结构并写方法区，实际写方法区具体是发生在加载、链接、初始化的哪个环节呢？")]),a._v(" "),s("p",[a._v("作者回复: 在加载阶段就已经生成class结构了，所以我认为应该已经写入了方法区，只是被标记为未链接而暂不能使用。")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("志远")]),a._v(" "),s("p",[a._v("2018-07-25")]),a._v(" "),s("p",[a._v("3")]),a._v(" "),s("p",[a._v("请问，关于双亲委派类加载器的情况，与周志明的深入理解java虚拟机矛盾啊，到底听哪个呢？周志明书籍中lib/ext是由扩展类加载器加载，你这里是启动类加载器加载，到底哪个是正确的呢？")]),a._v(" "),s("p",[a._v("作者回复: lib/ext是由扩展类加载器加载的，我文中应该也是这样讲的。")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("airfly")]),a._v(" "),s("p",[a._v("2019-02-28")]),a._v(" "),s("p",[a._v("2")]),a._v(" "),s("p",[a._v("没明白java虚拟机和类加载器的关系,")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("Geek_43687...")]),a._v(" "),s("p",[a._v("2018-12-22")]),a._v(" "),s("p",[a._v("2")]),a._v(" "),s("p",[a._v("看完了整篇文章，其实我还是没搞明白，加载-链接-初始化  这三个步骤的关系。首先我理解加载就是把编译好的.class文件读如jvm内存，存放至方法区。至于链接，我觉得暂时不用去深究。初始化则是比较常见的，我们去new操作或者访问静态变量时会触发类的初始化操作。我的问题是：1.什么时候触发类加载？2:加载-链接-初始化一定是三者都发生的吗，会存在某个累只加载，不链接，不初始化的情况吗")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("Eric")]),a._v(" "),s("p",[a._v("2018-09-24")]),a._v(" "),s("p",[a._v("2")]),a._v(" "),s("p",[a._v('关于新建数组是否会链接，第二个实践生成一个不能通过链接的验证阶段的类，但是我不明白怎么确定它是在new LazyHolder[2]时验证还是在return LazyHolder.INSTANCE时验证的？运行了指令后得到：\nError: A JNI error has occurred, please check your installation and try again\nException in thread "main" java.lang.VerifyError: Operand stack overflow\nException Details:\nLocation:\nSingleton.'),s("init",[a._v("()V @0: aload_0\n可不可以这样理解：新建数组new LazyHolder[2]不需要初始化，只有return  LazyHolder.INSTANCE才会导致初始化。而验证不通过的地方为初始化部分，所以，可以认为新建数组不会链接元素类LazyHolder；在getInstance(false)时才真正链接和初始化。")])],1),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("hero")]),a._v(" "),s("p",[a._v("2018-07-26")]),a._v(" "),s("p",[a._v("2")]),a._v(" "),s("p",[a._v("你该加油了，期待接下来精彩……")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("funnyx")]),a._v(" "),s("p",[a._v("2018-07-25")]),a._v(" "),s("p",[a._v("2")]),a._v(" "),s("p",[a._v("有两个问题想问一下老师，在类加载的过程中，有一个委派模式，这里严格来说应该不是使用的继承方式，应该是组合。另一个就是类中的静态字段，如果没有被jvm标记为常量，那么这部分内存是如何分配的？")]),a._v(" "),s("p",[a._v("作者回复: 前面那个问题，你说的没错。这么说的原因是它委派的那个对象名字叫parent。可能翻译为双亲比较不容易混淆。")]),a._v(" "),s("p",[a._v("后面那个问题，JVM都会分配内存的，只是初始化的过程不一样，一个是JVM直接赋值，一个是在clinit方法中赋值")])])}),[],!1,null,null,null);s.default=e.exports}}]);