(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{656:function(a,s,v){"use strict";v.r(s);var n=v(0),r=Object(n.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"_12-垃圾回收-下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-垃圾回收-下"}},[a._v("#")]),a._v(" 12 | 垃圾回收（下）")]),a._v(" "),s("p",[a._v("在读博士的时候，我曾经写过一个统计 Java 对象生命周期的动态分析，并且用它来跑了一些基准测试。")]),a._v(" "),s("p",[a._v("其中一些程序的结果，恰好验证了许多研究人员的假设，即大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/05/31/image-20220531143600055-f436ef.png",alt:"image-20220531143600055"}})]),a._v(" "),s("p",[a._v("（pmd 中 Java 对象生命周期的直方图，红色的表示被逃逸分析优化掉的对象）")]),a._v(" "),s("p",[a._v("之所以要提到这个假设，是因为它造就了 Java 虚拟机的分代回收思想。简单来说，就是将堆空间划分为两代，分别叫做新生代和老年代。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。")]),a._v(" "),s("p",[a._v("Java 虚拟机可以给不同代使用不同的回收算法。对于新生代，我们猜测大部分的 Java 对象只存活一小段时间，那么便可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。")]),a._v(" "),s("p",[a._v("对于老年代，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。")]),a._v(" "),s("p",[a._v("这时候，Java 虚拟机往往需要做一次全堆扫描，耗时也将不计成本。（当然，现代的垃圾回收器都在并发收集的道路上发展，来避免这种全堆扫描的情况。）")]),a._v(" "),s("p",[a._v("今天这一篇我们来关注一下针对新生代的 Minor GC。首先，我们来看看 Java 虚拟机中的堆具体是怎么划分的。")]),a._v(" "),s("h2",{attrs:{id:"java-虚拟机的堆划分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-虚拟机的堆划分"}},[a._v("#")]),a._v(" Java 虚拟机的堆划分")]),a._v(" "),s("p",[a._v("前面提到，Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。")]),a._v(" "),s("p",[a._v("默认情况下，Java 虚拟机采取的是一种动态分配的策略（对应 Java 虚拟机参数  -XX:+UsePSAdaptiveSurvivorSizePolicy），根据生成对象的速率，以及 Survivor 区的使用情况动态调整  Eden 区和 Survivor 区的比例。")]),a._v(" "),s("p",[a._v("当然，你也可以通过参数 -XX:SurvivorRatio 来固定这个比例。但是需要注意的是，其中一个 Survivor 区会一直为空，因此比例越低浪费的堆空间将越高。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/05/31/image-20220531143607413-8998d6.png",alt:"image-20220531143607413"}})]),a._v(" "),s("p",[a._v("通常来说，当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。")]),a._v(" "),s("p",[a._v("否则，将有可能出现两个对象共用一段内存的事故。如果你还记得前两篇我用“停车位”打的比方的话，这里就相当于两个司机（线程）同时将车停入同一个停车位，因而发生剐蹭事故。")]),a._v(" "),s("p",[a._v("Java 虚拟机的解决方法是为每个司机预先申请多个停车位，并且只允许该司机停在自己的停车位上。那么当司机的停车位用完了该怎么办呢（假设这个司机代客泊车）？")]),a._v(" "),s("p",[a._v("答案是：再申请多个停车位便可以了。这项技术被称之为 TLAB（Thread Local Allocation Buffer，对应虚拟机参数 -XX:+UseTLAB，默认开启）。")]),a._v(" "),s("p",[a._v("具体来说，每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的 TLAB。")]),a._v(" "),s("p",[a._v("这个操作需要加锁，线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。")]),a._v(" "),s("p",[a._v("接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。")]),a._v(" "),s("blockquote",[s("p",[a._v("我猜测会有留言问为什么不把 bump the pointer  翻译成指针碰撞。这里先解释一下，在英语中我们通常省略了 bump up the pointer 中的 up。在这个上下文中 bump  的含义应为“提高”。另外一个例子是当我们发布软件的新版本时，也会说 bump the version number。")])]),a._v(" "),s("p",[a._v("如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。")]),a._v(" "),s("p",[a._v("当 Eden 区的空间耗尽了怎么办？这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。")]),a._v(" "),s("p",[a._v("前面提到，新生代共有两个 Survivor 区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivior 区是空的。")]),a._v(" "),s("p",[a._v("当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。")]),a._v(" "),s("p",[a._v("Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数  -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor  区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。")]),a._v(" "),s("p",[a._v("总而言之，当发生 Minor GC 时，我们应用了标记 - 复制算法，将 Survivor  区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理想情况下，Eden  区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。")]),a._v(" "),s("p",[a._v("Minor GC  的另外一个好处是不用对整个堆进行垃圾回收。但是，它却有一个问题，那就是老年代的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。")]),a._v(" "),s("p",[a._v("这样一来，岂不是又做了一次全堆扫描呢？")]),a._v(" "),s("h2",{attrs:{id:"卡表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#卡表"}},[a._v("#")]),a._v(" 卡表")]),a._v(" "),s("p",[a._v("HotSpot 给出的解决方案是一项叫做卡表（Card Table）的技术。该技术将整个堆划分为一个个大小为 512  字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。")]),a._v(" "),s("p",[a._v("在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。")]),a._v(" "),s("p",[a._v("由于 Minor GC 伴随着存活对象的复制，而复制需要更新指向该对象的引用。因此，在更新引用的同时，我们又会设置引用所在的卡的标识位。这个时候，我们可以确保脏卡中必定包含指向新生代对象的引用。")]),a._v(" "),s("p",[a._v("在 Minor GC 之前，我们并不能确保脏卡中包含指向新生代对象的引用。其原因和如何设置卡的标识位有关。")]),a._v(" "),s("p",[a._v("首先，如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。")]),a._v(" "),s("p",[a._v("这个操作在解释执行器中比较容易实现。但是在即时编译器生成的机器码中，则需要插入额外的逻辑。这也就是所谓的写屏障（write barrier，注意不要和 volatile 字段的写屏障混淆）。")]),a._v(" "),s("p",[a._v("写屏障需要尽可能地保持简洁。这是因为我们并不希望在每条引用型实例变量的写指令后跟着一大串注入的指令。")]),a._v(" "),s("p",[a._v("因此，写屏障并不会判断更新后的引用是否指向新生代中的对象，而是宁可错杀，不可放过，一律当成可能指向新生代对象的引用。")]),a._v(" "),s("p",[a._v("这么一来，写屏障便可精简为下面的伪代码 [1]。这里右移 9 位相当于除以 512，Java 虚拟机便是通过这种方式来从地址映射到卡表中的索引的。最终，这段代码会被编译成一条移位指令和一条存储指令。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\nCARD_TABLE [this address >> 9] = DIRTY;\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")]),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("虽然写屏障不可避免地带来一些开销，但是它能够加大 Minor GC 的吞吐率（ 应用运行时间 /(应用运行时间 + 垃圾回收时间) ）。总的来说还是值得的。不过，在高并发环境下，写屏障又带来了虚共享（false sharing）问题 [2]。")]),a._v(" "),s("p",[a._v("在介绍对象内存布局中我曾提到虚共享问题，讲的是几个 volatile 字段出现在同一缓存行里造成的虚共享。这里的虚共享则是卡表中不同卡的标识位之间的虚共享问题。")]),a._v(" "),s("p",[a._v("在 HotSpot 中，卡表是通过 byte 数组来实现的。对于一个 64 字节的缓存行来说，如果用它来加载部分卡表，那么它将对应 64 张卡，也就是 32KB 的内存。")]),a._v(" "),s("p",[a._v("如果同时有两个 Java 线程，在这 32KB 内存中进行引用更新操作，那么也将造成存储卡表的同一部分的缓存行的写回、无效化或者同步操作，因而间接影响程序性能。")]),a._v(" "),s("p",[a._v("为此，HotSpot 引入了一个新的参数 -XX:+UseCondCardMark，来尽量减少写卡表的操作。其伪代码如下所示：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\nif (CARD_TABLE [this address >> 9] != DIRTY) \n\n  CARD_TABLE [this address >> 9] = DIRTY;\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")]),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("h2",{attrs:{id:"总结与实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结与实践"}},[a._v("#")]),a._v(" 总结与实践")]),a._v(" "),s("p",[a._v("今天我介绍了 Java 虚拟机中垃圾回收具体实现的一些通用知识。")]),a._v(" "),s("p",[a._v("Java 虚拟机将堆分为新生代和老年代，并且对不同代采用不同的垃圾回收算法。其中，新生代分为 Eden 区和两个大小一致的 Survivor 区，并且其中一个 Survivor 区是空的。")]),a._v(" "),s("p",[a._v("在只针对新生代的 Minor GC 中，Eden 区和非空 Survivor 区的存活对象会被复制到空的 Survivor 区中，当 Survivor 区中的存活对象复制次数超过一定数值时，它将被晋升至老年代。")]),a._v(" "),s("p",[a._v("因为 Minor GC 只针对新生代进行垃圾回收，所以在枚举 GC Roots 的时候，它需要考虑从老年代到新生代的引用。为了避免扫描整个老年代，Java 虚拟机引入了名为卡表的技术，大致地标出可能存在老年代到新生代引用的内存区域。")]),a._v(" "),s("p",[a._v("由于篇幅的原因，我没有讲解 Java 虚拟机中具体的垃圾回收器。我在文章的末尾附了一段简单的介绍，如果你有兴趣的话可以参阅一下。")]),a._v(" "),s("p",[a._v("今天的实践环节，我们来看看 Java 对象的生命周期对垃圾回收的影响。")]),a._v(" "),s("p",[a._v("前面提到，Java 虚拟机的分代垃圾回收是基于大部分对象只存活一小段时间，小部分对象却存活一大段时间的假设的。")]),a._v(" "),s("p",[a._v("然而，现实情况中并非每个程序都符合前面提到的假设。如果一个程序拥有中等生命周期的对象，并且刚移动到老年代便不再使用，那么将给默认的垃圾回收策略造成极大的麻烦。")]),a._v(" "),s("p",[a._v("下面这段程序将生成 64G 的 Java 对象。并且，我通过 ALIVE_OBJECT_SIZE 这一变量来定义同时存活的 Java 对象的大小。这也是一种对于垃圾回收器来说比较直观的生命周期。")]),a._v(" "),s("p",[a._v("当我们使用 Java 8 的默认 GC，并且将新生代的空间限制在 100M 时，试着估算当 ALIVE_OBJECT_SIZE  为多少时，这段程序不会触发 Full GC（提示一下，如果 Survivor 区没法存储所有存活对象，将发生什么。）。实际运行情况又是怎么样的？")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\n// Run with java -XX:+PrintGC -Xmn100M -XX:PretenureSizeThreshold=10000 LifetimeTest\n\n// You may also try with -XX:+PrintHeapAtGC，-XX:-UsePSAdaptiveSurvivorSizePolicy or -XX:SurvivorRatio=N\n\npublic class LifetimeTest {\n\n  private static final int K = 1024;\n\n  private static final int M = K * K;\n\n  private static final int G = K * M;\n\n \n\n  private static final int ALIVE_OBJECT_SIZE = 32 * M;\n\n \n\n  public static void main(String[] args) {\n\n    int length = ALIVE_OBJECT_SIZE / 64;\n\n    ObjectOf64Bytes[] array = new ObjectOf64Bytes[length];\n\n    for (long i = 0; i < G; i++) {\n\n      array[(int) (i % length)] = new ObjectOf64Bytes();\n\n    }\n\n  }\n\n}\n\n \n\nclass ObjectOf64Bytes {\n\n  long placeholder0;\n\n  long placeholder1;\n\n  long placeholder2;\n\n  long placeholder3;\n\n  long placeholder4;\n\n  long placeholder5;\n\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br"),s("span",{staticClass:"line-number"},[a._v("30")]),s("br"),s("span",{staticClass:"line-number"},[a._v("31")]),s("br"),s("span",{staticClass:"line-number"},[a._v("32")]),s("br"),s("span",{staticClass:"line-number"},[a._v("33")]),s("br"),s("span",{staticClass:"line-number"},[a._v("34")]),s("br"),s("span",{staticClass:"line-number"},[a._v("35")]),s("br"),s("span",{staticClass:"line-number"},[a._v("36")]),s("br"),s("span",{staticClass:"line-number"},[a._v("37")]),s("br"),s("span",{staticClass:"line-number"},[a._v("38")]),s("br"),s("span",{staticClass:"line-number"},[a._v("39")]),s("br"),s("span",{staticClass:"line-number"},[a._v("40")]),s("br"),s("span",{staticClass:"line-number"},[a._v("41")]),s("br"),s("span",{staticClass:"line-number"},[a._v("42")]),s("br"),s("span",{staticClass:"line-number"},[a._v("43")]),s("br"),s("span",{staticClass:"line-number"},[a._v("44")]),s("br"),s("span",{staticClass:"line-number"},[a._v("45")]),s("br"),s("span",{staticClass:"line-number"},[a._v("46")]),s("br"),s("span",{staticClass:"line-number"},[a._v("47")]),s("br"),s("span",{staticClass:"line-number"},[a._v("48")]),s("br"),s("span",{staticClass:"line-number"},[a._v("49")]),s("br"),s("span",{staticClass:"line-number"},[a._v("50")]),s("br"),s("span",{staticClass:"line-number"},[a._v("51")]),s("br"),s("span",{staticClass:"line-number"},[a._v("52")]),s("br")]),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br"),s("span",{staticClass:"line-number"},[a._v("30")]),s("br"),s("span",{staticClass:"line-number"},[a._v("31")]),s("br"),s("span",{staticClass:"line-number"},[a._v("32")]),s("br"),s("span",{staticClass:"line-number"},[a._v("33")]),s("br"),s("span",{staticClass:"line-number"},[a._v("34")]),s("br"),s("span",{staticClass:"line-number"},[a._v("35")]),s("br"),s("span",{staticClass:"line-number"},[a._v("36")]),s("br"),s("span",{staticClass:"line-number"},[a._v("37")]),s("br"),s("span",{staticClass:"line-number"},[a._v("38")]),s("br"),s("span",{staticClass:"line-number"},[a._v("39")]),s("br"),s("span",{staticClass:"line-number"},[a._v("40")]),s("br"),s("span",{staticClass:"line-number"},[a._v("41")]),s("br"),s("span",{staticClass:"line-number"},[a._v("42")]),s("br"),s("span",{staticClass:"line-number"},[a._v("43")]),s("br"),s("span",{staticClass:"line-number"},[a._v("44")]),s("br"),s("span",{staticClass:"line-number"},[a._v("45")]),s("br"),s("span",{staticClass:"line-number"},[a._v("46")]),s("br"),s("span",{staticClass:"line-number"},[a._v("47")]),s("br"),s("span",{staticClass:"line-number"},[a._v("48")]),s("br"),s("span",{staticClass:"line-number"},[a._v("49")]),s("br"),s("span",{staticClass:"line-number"},[a._v("50")]),s("br"),s("span",{staticClass:"line-number"},[a._v("51")]),s("br"),s("span",{staticClass:"line-number"},[a._v("52")]),s("br")])]),s("h2",{attrs:{id:"附录-java-虚拟机中的垃圾回收器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#附录-java-虚拟机中的垃圾回收器"}},[a._v("#")]),a._v(" 附录：Java 虚拟机中的垃圾回收器")]),a._v(" "),s("p",[a._v("针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是标记 -  复制算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。")]),a._v(" "),s("p",[a._v("针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是标记 - 压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。")]),a._v(" "),s("p",[a._v("CMS 采用的是标记 - 清除算法，并且是并发的。除了少数几个操作需要 Stop-the-world  之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃 [3]。")]),a._v(" "),s("p",[a._v("G1（Garbage  First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden  区、Survivor 区或者老年代中的一个。它采用的是标记 - 压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。")]),a._v(" "),s("p",[a._v("G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。")]),a._v(" "),s("p",[a._v("即将到来的 Java 11 引入了 ZGC，宣称暂停时间不超过 10ms。如果你感兴趣的话，可参考 R 大的这篇文章 [4]。")]),a._v(" "),s("p",[a._v("[1]\nhttp://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\n[2]\nhttps://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking\n[3]\nhttp://openjdk.java.net/jeps/291\n[4]  https://www.zhihu.com/question/287945354/answer/458761494")]),a._v(" "),s("h2",{attrs:{id:"精选留言-45"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#精选留言-45"}},[a._v("#")]),a._v(" 精选留言(45)")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("godtrue 置顶")]),a._v(" "),s("p",[a._v("2018-08-21")]),a._v(" "),s("p",[a._v("16")]),a._v(" "),s("p",[a._v("写的非常棒，又帮我看到了一个小黑盒中的天地。\n小结：\n1:二八法则-适用于许多的领域，对象在JVM对内存空间的生命周期也同样符合")]),a._v(" "),s("p",[a._v("2:为了更好的JVM性能以及充分利用对象生命周期的二八法则，JVM的作者将JVM的对内存空间进行了分代的处理")]),a._v(" "),s("p",[a._v("3:堆内存空间=年轻代+老年代")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("年轻代=Eden+from+to\n年轻代用于分配新生的对象\nEden-通常用于存储新创建的对象，对内存空间是共享的，所以，直接在这里面划分空间需要进行同步\n from-当Eden区的空间耗尽时，JVM便会出发一次Minor GC 来收集新生代的垃圾，会把存活下来的对象放入Survivor区，也就是from区\n")])])]),s("p",[a._v("注意，from和to是变动的\nto-指向的Survivor区是空的，用于当发生Minor GC 时，存储Eden和from区中的存活对象，然后再交换from和to指针，以保证下一次Minor GC 时to指向的Survivor区还是空的。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v(" 老年代-用于存储存活时间更久的对象，比如：15次Minor GC 还存活的对象就放入老年代中\n")])])]),s("p",[a._v("4:堆内存分代后，会根据他们的不同特点来区别对待，进行垃圾回收的时候会使用不同的垃圾回收方式，针对新生代的垃圾回收器有如下三个：Serial、Parallel Scavenge、Parallel New，他们采用的都是标记-复制的垃圾回收算法。\n针对老年代的垃圾回收器有如下三个：Serial Old 、Parallel Old 、CMS，他们使用的都是标记-压缩的垃圾回收算法。")]),a._v(" "),s("p",[a._v("5:TLAB（Thread Local Allocation Buffer）-这个技术是用于解决多线程竞争堆内存分配问题的，核心原理是对分配一些连续的内存空间")]),a._v(" "),s("p",[a._v("6:卡表-这个技术是用于解决减少老年代的全堆空间扫描")]),a._v(" "),s("p",[a._v("作者回复: 好长的总结，赞一个")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("javaadu")]),a._v(" "),s("p",[a._v("2018-08-17")]),a._v(" "),s("p",[a._v("7")]),a._v(" "),s("p",[a._v("写得真好，搞清楚了之前没掌握透彻的概念：\n（1）TLAB是为了避免对象分配时对内存的竞争\n（2）卡表是为了处理minor gc时老年代对新生代的引用，为了避免整堆扫描而提出了卡表的概念")]),a._v(" "),s("p",[a._v("提个问题：JVM中堆内存根系统的物理内存是如何对应的，这个可以从哪里看？")]),a._v(" "),s("p",[a._v("作者回复: 根系统指的是？")]),a._v(" "),s("p",[a._v("GC roots分布在HotSpot中的每个子系统里。可以在源码中搜oops_do")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("公子_小白")]),a._v(" "),s("p",[a._v("2018-08-23")]),a._v(" "),s("p",[a._v("4")]),a._v(" "),s("p",[a._v("老师您好\n请问JVM分代收集新生代对象进入老年代，年龄为什么是15而不是其他的?\n谢谢")]),a._v(" "),s("p",[a._v("作者回复: HotSpot会在对象头中的标记字段里记录年龄，分配到的空间只有4位，最多只能记录到15")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("素丶")]),a._v(" "),s("p",[a._v("2018-11-20")]),a._v(" "),s("p",[a._v("3")]),a._v(" "),s("p",[a._v("可以配合R大的文章\nhttp://rednaxelafx.iteye.com/blog/1042471\nhttp://rednaxelafx.iteye.com/blog/174865\nhttp://rednaxelafx.iteye.com/blog/1044951")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("herome")]),a._v(" "),s("p",[a._v("2018-08-19")]),a._v(" "),s("p",[a._v("3")]),a._v(" "),s("p",[a._v("老师 建议是能画点图吗 😂  每一篇都是文字。 相信画了图 不仅能让文章通俗易懂，也能让老师的文笔更好。")]),a._v(" "),s("p",[a._v("作者回复: 多谢建议！")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("愤怒的虾干")]),a._v(" "),s("p",[a._v("2019-02-19")]),a._v(" "),s("p",[a._v("2")]),a._v(" "),s("p",[a._v("1、当默认开启动态分配时，若ALIVE_OBJECT_SIZE小于33M几乎无FULL GC，大于则出现FULL  GC。动态分配时Eden区大小不能小于Survivor区，即最少为新生代内存的1/3，单个Survivor区最大为新生代内存的1/3。故当ALIVE_OBJECT_SIZE大于33M时，Survivor区小于ALIVE_OBJECT_SIZE，导致Minor GC时需要复制到to区的数据大于to区容量，从而使得一部分数据提前晋升到老年区，多次提前晋升导致老年区无多余空间从而导致Full  GC；当ALIVE_OBJECT_SIZE小于33M时，Survivor区容量总是近似的接近ALIVE_OBJECT_SIZE大小，使得每次Minor  GC有效对象都可以复制到Survivor区，而晋升到老年代的对象大多是年龄达到次数要求，短期内不会挤满老年代空间，在有限时间内运行结束不会引发Full GC。\n2、当-XX:-UsePSAdaptiveSurvivorSizePolicy or  -XX:SurvivorRatio=N关闭动态分配或指定Eden、Survivor比例时，只要ALIVE_OBJECT_SIZE小于Survivor容量，有限时间运行结束不会引发Full GC。反之会导致Full GC。\n@郑老师 是否是这样？")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("公子_小白")]),a._v(" "),s("p",[a._v("2018-08-24")]),a._v(" "),s("p",[a._v("2")]),a._v(" "),s("p",[a._v("多谢老师的回复")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("西兹兹")]),a._v(" "),s("p",[a._v("2019-01-19")]),a._v(" "),s("p",[a._v("1")]),a._v(" "),s("p",[a._v("老师好，请问java8开始之后的元数据区的回收是如何呢？这部分属于堆外内存吗？")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("多巴胺老邮...")]),a._v(" "),s("p",[a._v("2018-12-20")]),a._v(" "),s("p",[a._v("1")]),a._v(" "),s("p",[a._v("郑老师您好 ！ 一直想问问CMS收集器中并发标记这一个步骤的作用是什么 ？ 为什么还要在初始标记的基础上多进行一次Roots Tracing呢？ 希望您能有空能够回复下 thx")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("骑车吃火锅")]),a._v(" "),s("p",[a._v("2018-12-11")]),a._v(" "),s("p",[a._v("1")]),a._v(" "),s("p",[a._v("请问老师，java类是如何被卸载的？")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("Leon Wong")]),a._v(" "),s("p",[a._v("2018-09-12")]),a._v(" "),s("p",[a._v("1")]),a._v(" "),s("p",[a._v("老师你好，写屏障不会判断引用是否指向新生代的对象，这里会不会提高MinorGC的成本呢？")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("code-arti...")]),a._v(" "),s("p",[a._v("2018-08-17")]),a._v(" "),s("p",[a._v("1")]),a._v(" "),s("p",[a._v("通过GC_roots探索存活对象的时候，有的对象在新生代，有的对象在老年代。如果当前对象处在老年代而且在赃卡中，需要继续深度遍历对象。若不在赃卡中，就没必要进一步深度遍历下去了。不知道我的理解对不？")]),a._v(" "),s("p",[a._v("作者回复: 对的。卡表就是为了避免探索整个老年代，而只将脏表中的对象作为GC roots。")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("nero")]),a._v(" "),s("p",[a._v("2019-04-26")]),a._v(" "),s("p",[a._v("这也太狠了")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("Theodore")]),a._v(" "),s("p",[a._v("2019-04-04")]),a._v(" "),s("p",[a._v("老师您好，我想咨询一下，你是否研究过类的GC。\n在大量反射、动态代理，CGLib等Bytecode框架、动态生成jsp 等动态类对象（非实例对象）在jdk1.8中是否是使用MethodHandle实现的？这些动态类的GC细节能给我提供点学习资料吗？")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("Jadic")]),a._v(" "),s("p",[a._v("2019-03-22")]),a._v(" "),s("p",[a._v("hi，想了解下，当前线程在申请TLAB的时候是如何决定本次申请的空间大小的，如何尽量不浪费又少申请次数？谢谢。")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("XuYJ")]),a._v(" "),s("p",[a._v("2019-03-19")]),a._v(" "),s("p",[a._v("cms不是标记清除吗")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("rakitten")]),a._v(" "),s("p",[a._v("2019-01-25")]),a._v(" "),s("p",[a._v("有两个问题想请教一下郑老师：\n1、介绍GC的文档很多，我有个疑问：GC的代码哪里能看到？\n2、我们的后台服务一天内偶尔出现一次YGC耗时很长的情况（超过100ms，正常只有20ms），而且很难复现。我在想，能不能在GC发生的时候，触发一个Linux脚本，记录现场的线程信息以及堆栈信息")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("小泷哥")]),a._v(" "),s("p",[a._v("2018-12-23")]),a._v(" "),s("p",[a._v("可以这么理解吗：\n1、卡表记录老年代执行新生代的引用\n2、老年代的引用变更都会被当做堆新生代的引用，记录在卡表中。\n3、只需要在老年代GC的时候，执行一次minor GC就行了，清理card table(包括CMS和G1)。")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("life is ...")]),a._v(" "),s("p",[a._v("2018-11-14")]),a._v(" "),s("p",[a._v("记载来自一个刚刚迈进程序世界的coder")]),a._v(" "),s("p",[a._v("java对象的生存周期")]),a._v(" "),s("p",[a._v("大部分对象的生命周期都很短，小部分对象的生命周期很长。")]),a._v(" "),s("p",[a._v("因为这个特点，可以对jvm内存分代，不同代采用不同的回收方式。")]),a._v(" "),s("p",[a._v("年轻代要采用频繁的回收方式，快速回收大部分垃圾。老年代则采用不频繁但彻底的回收方式。")]),a._v(" "),s("p",[a._v("JVM堆的划分")]),a._v(" "),s("p",[a._v("因为对象以上的特点，将堆分为两个代，老年代和新生代。新生代分为Eden和两个Survivor区。可以使用参数  “”，会动态的根据对象的生成速率以及survivor区的使用情况，调整Eden区和survivor区的比例。也可以使用参数“”，来固定Eden和survivor的比例。")]),a._v(" "),s("p",[a._v("如何保证内存分配的线程安全")]),a._v(" "),s("p",[a._v("堆是共享的，所有的线程都会在堆上分配内存，那么jvm是如何保证内存分配是线程安全的？答案是，每个线程都会有TLAB(thread local allocation  buffer)，这个是线程私有的。首先会在TLAB上分配，如果TLAB不够用，就需要通过加锁的方式，申请TLAB。")]),a._v(" "),s("p",[a._v("Eden区满了")]),a._v(" "),s("p",[a._v("触发minor GC，eden和from依旧存活的对象会放置到to区。然后交换from  to指针的指向。其中达到经历过一定回收次数的对象将会被晋升到老年代，对应JVM参数[]。同时如果也配置了[]参数，单个survivor区占用超过50%，经历次数较高的对象也会晋升到老年代。")]),a._v(" "),s("p",[a._v("先提前说一个结论，minor GC有一个好处，发生GC时不会遍历堆内存，只会遍历Eden+survivor区！讲道理，老年代很可能拥有Eden+survivor区对象的引用，那minor GC只遍历年轻代，是怎么做到GC的呢？")]),a._v(" "),s("p",[a._v("卡表")]),a._v(" "),s("p",[a._v("HotSpot会将堆分割成一个个512字节大小的卡，然后维护一张卡表，每个卡在表中占据一个卡位。")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("p",[a._v("QlDoors")]),a._v(" "),s("p",[a._v("2018-11-12")]),a._v(" "),s("p",[a._v("< 1/2 Suvivors 时，不会发生Full GC")])])}),[],!1,null,null,null);s.default=r.exports}}]);