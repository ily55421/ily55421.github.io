(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{412:function(r,t,n){"use strict";n.r(t);var e=n(0),v=Object(e.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"算法模板"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法模板"}},[r._v("#")]),r._v(" 算法模板")]),r._v(" "),t("p",[r._v("今天开始进行算法模板的复习和整理。授人以鱼，不如授人以渔。在本讲，我的目的是教会你如何做知识的整理和模板的整理，而不是直接给你一些现成的东西，让你去死记硬背。无论是思维导图，还是代码模板，你自己整理一遍的收获会更大。")]),r._v(" "),t("p",[r._v("今天我们主要介绍两种方法：")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("通过思维导图将学过的知识添加到你的知识树中；")])]),r._v(" "),t("li",[t("p",[r._v("将刷过的题目整理成代码模板，放到你的代码模板库中。")])])]),r._v(" "),t("h3",{attrs:{id:"排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[r._v("#")]),r._v(" 排序")]),r._v(" "),t("p",[r._v("我们在学习排序的时候，主要讨论了合并模板和快速排序两种排序，现在就可以利用下面这个思维导图进行快速复习。")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/CioPOWCeKsyAZhzxAAKp0wZR38g731-be54ba.png",alt:"Drawing 0.png"}})]),r._v(" "),t("h4",{attrs:{id:"合并的技巧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合并的技巧"}},[r._v("#")]),r._v(" 合并的技巧")]),r._v(" "),t("p",[r._v("对于合并排序来说，我觉得最重要的是掌握下面这段合并的小技巧：")]),r._v(" "),t("p",[r._v("int i = b;"),t("br"),r._v("\n   int j = m;"),t("br"),r._v("\n   int to = b;"),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 将两个子数组进行合并, 注意下面是一个很重要的模板")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 这里的判断条，是只要两个子数组中还有元素")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("while")]),r._v(" (i < m || j < e) {"),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 如果右子数组没有元素 或 左子数组开头的元素小于右子数组开头的元素")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 那么取走左子数组开头的元素")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 考点：a[i] <= a[j]这样可以保证合并排序是稳定的，不要写错!")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("if")]),r._v(" (j >= e || i < m && a[i] <= a[j]) {"),t("br"),r._v("\n   t[to++] = a[i++];"),t("br"),r._v("\n} "),t("span",{staticClass:"hljs-keyword"},[r._v("else")]),r._v(" {"),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 否则就是取右子数组开头的元素")]),t("br"),r._v("\n   t[to++] = a[j++];"),t("br"),r._v("\n}"),t("br"),r._v("\n}")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F08.Sort%2FmergeSort.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F08.Sort%2FmergeSort.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F08.Sort%2FmergeSort.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[r._v("可以看到 while 语句中 if 语句的写法（上述代码第 11 行）用了最简洁的代码处理了各种边界条件！")]),r._v(" "),t("h4",{attrs:{id:"三路切分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三路切分"}},[r._v("#")]),r._v(" 三路切分")]),r._v(" "),t("p",[r._v("在"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6697%26fileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("《08 | 排序：如何利用合并与快排的小技巧，解决算法难题？》"),t("OutboundLink")],1),r._v("介绍快速排序时，三路切分也是一个高频出现的知识点，所以我们需要掌握这个代码模板，如下所示：")]),r._v(" "),t("p",[r._v("// 辅助函数：交换数组中的两个元素"),t("br"),r._v("\nvoid swap(int[] A, int i, int j) {"),t("br"),r._v("\nint t = A[i];"),t("br"),r._v("\nA[i] = A[j];"),t("br"),r._v("\nA[j] = t;"),t("br"),r._v("\n}"),t("br"),r._v("\n// 三路切分"),t("br"),r._v("\nint threeSplit(int[] A, int b, int e) {"),t("br"),r._v("\nif (b >= e) {"),t("br"),r._v("\n   return 0;"),t("br"),r._v("\n}"),t("br"),r._v("\n// 我们取数组中间的数"),t("br"),r._v("\nfinal int m = b + ((e - b) >> 1);"),t("br"),r._v("\nfinal int x = A[m];"),t("br"),r._v("\n// 注意我们的初始区间有四个："),t("br"),r._v("\n// [b, l) [l, i) [i, r] (r, N)"),t("br"),r._v("\n// [小于)  [等于) [未知]  (大于)"),t("br"),r._v("\nint l = b;"),t("br"),r._v("\nint i = b;"),t("br"),r._v("\nint r = e - 1;"),t("br"),r._v("\nwhile (i <= r) {"),t("br"),r._v("\n   if (A[i] < x) {"),t("br"),r._v("\n     swap(A, l++, i++);"),t("br"),r._v("\n   } else if (A[i] == x) {"),t("br"),r._v("\n     i++;"),t("br"),r._v("\n   } else {"),t("br"),r._v("\n     swap(A, r--, i);"),t("br"),r._v("\n   }"),t("br"),r._v("\n}"),t("br"),r._v("\n// 切分完毕之后，只有三个区间"),t("br"),r._v("\n// [b, l) [l, i) [i, N)"),t("br"),r._v("\n// 首先看中间的区间"),t("br"),r._v("\nif (i - l == 1)"),t("br"),r._v("\n   return A[l];"),t("br"),r._v("\n// 再看左区间"),t("br"),r._v("\nif (((l - b) & 0x01) == 1) {"),t("br"),r._v("\n   return threeSplit(A, b, l);"),t("br"),r._v("\n}"),t("br"),r._v("\n// 再看右区间"),t("br"),r._v("\nreturn threeSplit(A, i, e);"),t("br"),r._v("\n}")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F08.Sort%2F136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F08.Sort%2F136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F08.Sort%2F136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("h3",{attrs:{id:"二分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二分"}},[r._v("#")]),r._v(" 二分")]),r._v(" "),t("p",[r._v("我们将二分的知识点整理如下：")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://s0.lgstatic.com/i/image6/M01/3F/70/Cgp9HWCeKtqAJXLXAAJ_yPY2KLM148.png",alt:"Drawing 1.png"}})]),r._v(" "),t("p",[r._v("当已知一个题目可以用二分进行破解时，就可以使用 lowerBound 和 upperBound 这两个标准的二分的模板了。")]),r._v(" "),t("p",[r._v("此外，我们还需要记住这两个模板的使用的条件：")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("lowerBound 用于查找有序数组中最左边出现的元素（闭）。")])]),r._v(" "),t("li",[t("p",[r._v("upperBound 用于查找有序数组中最右边出现的元素（开）。")])])]),r._v(" "),t("p",[r._v("注意，我们在条件部分加了“"),t("strong",[r._v("开闭")]),r._v("”两个字！其含义如下：")]),r._v(" "),t("p",[r._v("当给定数组 A[] = {1,2,2,2,3}，运行 lowerBound(A, 2) 返回下标 1，而运行 upperBound(A,2) 却返回下标 4，但此时 A[4] = 3。")]),r._v(" "),t("p",[r._v("因此，我们还需要注意，lowerBound 与 upperBound 返回值组成的区间是一个"),t("strong",[r._v("左闭右开")]),r._v("的区间，如下所示：")]),r._v(" "),t("p",[r._v("[lowerBound(A,2), upperBound(A,2)) = [1, 4)")]),r._v(" "),t("p",[r._v("一定要记住这里的"),t("strong",[r._v("左闭右开原则")]),r._v("！")]),r._v(" "),t("h4",{attrs:{id:"lowerbound"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lowerbound"}},[r._v("#")]),r._v(" lowerBound")]),r._v(" "),t("p",[r._v("其中 lowerBound 的代码模板如下：")]),r._v(" "),t("p",[r._v("int lowerBound(long[] A, int n, long target) {"),t("br"),r._v("\nint l = 0, r = n;"),t("br"),r._v("\nwhile (l < r) {"),t("br"),r._v("\n   final int m = l + ((r - l) >> 1);"),t("br"),r._v("\n   if (A[m] < target) {"),t("br"),r._v("\n     l = m + 1;"),t("br"),r._v("\n   } else {"),t("br"),r._v("\n     r = m;"),t("br"),r._v("\n   }"),t("br"),r._v("\n}"),t("br"),r._v("\nreturn l;"),t("br"),r._v("\n}")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F09.BinarySearch%2FT1560.2.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F09.BinarySearch%2FT1560.2.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F09.BinarySearch%2FT1560.2.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("h4",{attrs:{id:"upperbound"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#upperbound"}},[r._v("#")]),r._v(" upperBound")]),r._v(" "),t("p",[r._v("upperBound 的"),t("strong",[r._v("模板代码")]),r._v("如下：")]),r._v(" "),t("p",[r._v("int upperBound(long[] A, int n, long target) {"),t("br"),r._v("\nint l = 0, r = n;"),t("br"),r._v("\nwhile (l < r) {"),t("br"),r._v("\n   final int m = l + ((r - l) >> 1);"),t("br"),r._v("\n   if (A[m] <= target) {"),t("br"),r._v("\n     l = m + 1;"),t("br"),r._v("\n   } else {"),t("br"),r._v("\n     r = m;"),t("br"),r._v("\n   }"),t("br"),r._v("\n}"),t("br"),r._v("\nreturn l;"),t("br"),r._v("\n}")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F09.BinarySearch%2FT1562.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F09.BinarySearch%2FT1562.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F09.BinarySearch%2FT1562.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[r._v("其实我们只需要记忆 lowerBound 模板就够了，因为两个模板之间的差异只有一处：")]),r._v(" "),t("blockquote",[t("p",[r._v("lowerBound：A[m] < target upperBound：A[m] <= target")])]),r._v(" "),t("p",[r._v("这里和你分享一个我的记忆方法。当 A[m] <= target 的时候，标志着 m 还可以往右移动一段距离，因为 upperBound 找到的一般都在更右边的位置，因此带有“A[m] <= target”的是 upperBound。")]),r._v(" "),t("h3",{attrs:{id:"双指针"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双指针"}},[r._v("#")]),r._v(" 双指针")]),r._v(" "),t("p",[r._v("双指针的知识我们总结如下：")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/Cgp9HWCeKvKAN-9UAAD_-oFBQLA882-12435c.png",alt:"Drawing 2.png"}})]),r._v(" "),t("p",[r._v("需要熟练掌握的代码模板，一共有 3 个。")]),r._v(" "),t("h4",{attrs:{id:"最长区间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最长区间"}},[r._v("#")]),r._v(" 最长区间")]),r._v(" "),t("p",[r._v("求最长区间的代码模板长成这样：")]),r._v(" "),t("p",[r._v("int maxLength(int[] A) {"),t("br"),r._v("\nint N = A.length;"),t("br"),r._v("\n// 区间的左指针"),t("br"),r._v("\nint left = -1;"),t("br"),r._v("\nint ans = 0;"),t("br"),r._v("\nfor (int i = 0; i < N; i++) {"),t("br"),r._v("\n   // assert 在加入A[i]之前，(left, i-1]是一个合法有效的区间"),t("br"),r._v("\n   // step 1. 直接将A[i]加到区间中，形成(left, i]"),t("br"),r._v("\n   // step 2. 将A[i]加入之后，惰性原则"),t("br"),r._v("\n   while (check((left, i]))/"),t("em",[r._v("TODO 检查区间状态是否满足条件")]),r._v("/) {"),t("br"),r._v("\n     ++left; // 如果不满足条件，移动左指针"),t("br"),r._v("\n     // TODO 修改区间的状态"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // assert 此时(left, i]必然满足条件"),t("br"),r._v("\n   ans = max(ans, i - left);"),t("br"),r._v("\n}"),t("br"),r._v("\nreturn ans; // 返回最优解"),t("br"),r._v("\n}")]),r._v(" "),t("p",[r._v("注意：在解题的时候，需要根据具体的题目条件，在模板的基础上写一点状态更新的代码，也就是要替换掉代码模板中的“TODO”部分。")]),r._v(" "),t("h4",{attrs:{id:"定长区间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定长区间"}},[r._v("#")]),r._v(" 定长区间")]),r._v(" "),t("p",[r._v("其实定长区间就是固定窗口大小的滑动窗口算法，这里我整理好了一个通用的模板，如下所示：")]),r._v(" "),t("p",[r._v("int fixedLength(int[] A, int windowSize) {"),t("br"),r._v("\nfinal int N = A == null ? 0 : A.length;"),t("br"),r._v("\nint left = -1;"),t("br"),r._v("\nfor (int i = 0; i < N; i++) {"),t("br"),r._v("\n   // step 1. 直接将A[i]加到区间中，形成(left, i]"),t("br"),r._v("\n   // TODO 修改区间的状态"),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 如果滑动窗口还太小")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("if")]),r._v(" (i - left < windowSize) {"),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("continue")]),r._v(";"),t("br"),r._v("\n}"),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// assert 此时(left, i]长度必然等于windowSize")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// TODO 判断区间的状态是否满足约束条件")]),t("br"),r._v("\nleft++;"),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// step 2. 移除A[left]")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// TODO 修改区间状态")]),t("br"),r._v("\n​"),t("br"),r._v("\n}"),t("br"),r._v("\nreturn ans; // 返回最优解")]),r._v(" "),t("p",[r._v("注意：这个代码模板也是需要根据具体的题目条件完成“TODO”的部分。不同的题目，状态更新的代码可能会稍有不同。")]),r._v(" "),t("h4",{attrs:{id:"最短区间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最短区间"}},[r._v("#")]),r._v(" 最短区间")]),r._v(" "),t("p",[r._v("最短区间的代码模板如下：")]),r._v(" "),t("p",[r._v("int minimalRange(int[] A) {"),t("br"),r._v("\nfinal int N = A == null ? 0 : A.length;"),t("br"),r._v("\n// 子串的左边，采用左开右闭原则(left, i]表示一个子串"),t("br"),r._v("\nint left = -1;"),t("br"),r._v("\n// 记录最短的子串的长度"),t("br"),r._v("\nint ans = A.length + 1;"),t("br"),r._v("\nfor (int i = 0; i < N; i++) {"),t("br"),r._v("\n   // 注意 在加入A[i]之前，(left, i-1]可能不满足条件!"),t("br"),r._v("\n   // step 1. 直接将A[i]加到区间中，形成(left, i]"),t("br"),r._v("\n   // step 2. TODO 更新区间的状态"),t("br"),r._v("\n   while (区间超出/满足条件) {"),t("br"),r._v("\n     ans = Math.min(ans, i - left);"),t("br"),r._v("\n     // step 3. 移除A[++left];"),t("br"),r._v("\n     // step 4. TODO 更新区间的状态"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // assert ! 区间(left, i]到这里肯定不满足条件"),t("br"),r._v("\n}"),t("br"),r._v("\nreturn ans;"),t("br"),r._v("\n}")]),r._v(" "),t("p",[r._v("注意：状态更新的代码同样需要根据题目的条件完成“TODO”的部分。")]),r._v(" "),t("h3",{attrs:{id:"贪心"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪心"}},[r._v("#")]),r._v(" 贪心")]),r._v(" "),t("p",[r._v("虽然说贪心算法是一种思想，不过还是有一些代码模板需要你掌握。比如"),t("strong",[r._v("区间不重复的最大数目模板")]),r._v("，如下所示：")]),r._v(" "),t("p",[r._v("int nonOverlapIntervals(int[][] A) {"),t("br"),r._v("\nfinal int N = A == null ? 0 : A.length;"),t("br"),r._v("\n// 将区间进行排序"),t("br"),r._v("\nArrays.sort(A, new Comparator<int[]>() {"),t("br"),r._v("\n   public int compare(int[] a, int[] b) {"),t("br"),r._v("\n     return a[1] == b[1] ? 0 : (a[1] < b[1] ? -1 : 1);"),t("br"),r._v("\n   }"),t("br"),r._v("\n});"),t("br"),r._v("\n// 已重叠的区间的最右端点"),t("br"),r._v("\nint maxEnd = Integer.MIN_VALUE;"),t("br"),r._v("\n// 不重叠 的区间的个数"),t("br"),r._v("\nint ans = 0;"),t("br"),r._v("\n// 开始贪心算法"),t("br"),r._v("\nfor (int i = 0; i < N; i++) {"),t("br"),r._v("\n   final int start = A[i][0];"),t("br"),r._v("\n   if (maxEnd <= start) {"),t("br"),r._v("\n     maxEnd = A[i][1];"),t("br"),r._v("\n     ans++;"),t("br"),r._v("\n   }"),t("br"),r._v("\n}"),t("br"),r._v("\nreturn ans;"),t("br"),r._v("\n}")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F11.Greedy%2FnonOverlap.1.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F11.Greedy%2FnonOverlap.1.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F11.Greedy%2FnonOverlap.1.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[r._v("此外，在"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6700%26fileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("《11 | 贪心：这种思想，没有模板，如何才能掌握它？》"),t("OutboundLink")],1),r._v("中我们介绍过“青蛙跳”问题， 实际上该解法还可以解决一系列题目，比如“"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6700%26fileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("第 11 讲"),t("OutboundLink")],1),r._v("”的练习题 5，练习题 6 等。因此，我把这个算法模板叫作"),t("strong",[r._v("青蛙跳模板")]),r._v("。")]),r._v(" "),t("p",[r._v("boolean canJump(int[] A) {"),t("br"),r._v("\nfinal int N = A == null ? 0 : A.length;"),t("br"),r._v("\n// 一开始，在正式开始第一次扫描之前，肯定什么元素都还没有扫描过"),t("br"),r._v("\n// 所以之记录之前扫描位置设置为-1"),t("br"),r._v("\nint preScanedPos = -1;"),t("br"),r._v("\n// 根据题意"),t("br"),r._v("\n// 当前能覆盖到数组的第0个元素。也就是当前可以够得着的元素"),t("br"),r._v("\nint curCoveredRange = 0;"),t("br"),r._v("\n// 如果当前"),t("br"),r._v("\nwhile (curCoveredRange < N - 1) {"),t("br"),r._v("\n   int oldCoveredRange = curCoveredRange;"),t("br"),r._v("\n   // 根据优化1和优化2，我们只需要遍历"),t("br"),r._v("\n   // [preScanedPos + 1, oldCoveredRange]即可。"),t("br"),r._v("\n   // 然后不停更新curCoveredRange"),t("br"),r._v("\n   for (int i = preScanedPos + 1; i <= oldCoveredRange; i++) {"),t("br"),r._v("\n     // 1. 这个区间和我们已经覆盖的范围是相连的!"),t("br"),r._v("\n     // 满足相连性"),t("br"),r._v("\n     // 2. 如果这个区间能覆盖得更远"),t("br"),r._v("\n     if (i + A[i] > curCoveredRange) {"),t("br"),r._v("\n       // 更新我们能cover的范围"),t("br"),r._v("\n       curCoveredRange = i + A[i];"),t("br"),r._v("\n     }"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 如果发现不能更新覆盖范围，说明已经没有变长的可能性了。"),t("br"),r._v("\n   if (oldCoveredRange == curCoveredRange) {"),t("br"),r._v("\n     return false;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 我们记住上次已经扫描过的位置"),t("br"),r._v("\n   preScanedPos = oldCoveredRange;"),t("br"),r._v("\n}"),t("br"),r._v("\nreturn true;"),t("br"),r._v("\n}")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F11.Greedy%2F55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F11.Greedy%2F55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F11.Greedy%2F55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("h3",{attrs:{id:"回溯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回溯"}},[r._v("#")]),r._v(" 回溯")]),r._v(" "),t("p",[r._v("关于回溯，我经常从两个方向思考：")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("只看第 i 个人怎么选；")])]),r._v(" "),t("li",[t("p",[r._v("“有借有还”。")])])]),r._v(" "),t("p",[r._v("关于这两点，希望你看了下面的这个思维导图还能够想起来。")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/Cgp9HWCeKwaAJ2zMAAIfg-QqiDc133-417b49.png",alt:"Drawing 3.png"}})]),r._v(" "),t("p",[r._v("回溯的代码模板只有一个，如下所示：")]),r._v(" "),t("p",[r._v("void backtrace(int[] A,"),t("br"),r._v("\n              int i, /"),t("em",[r._v("第i个人")]),r._v("/"),t("br"),r._v("\n              Box s, /"),t("em",[r._v("箱子")]),r._v("/"),t("br"),r._v("\n              answer/"),t("em",[r._v("存放所有的答案")]),r._v("/) {"),t("br"),r._v("\nfinal int N = A == null ? 0 : A.length;"),t("br"),r._v("\nif (状态满足要求) {"),t("br"),r._v("\n   answer.add(s);"),t("br"),r._v("\n}"),t("br"),r._v("\nif ([i, ...., 后面）的人都没有任何选项了) {"),t("br"),r._v("\nreturn;"),t("br"),r._v("\n}"),t("br"),r._v("\nfor 宝石 in {第i个人当前所有宝石选项} {"),t("br"),r._v("\ns.push(宝石);"),t("br"),r._v("\nbacktrace(A, i + 1, s, answer);"),t("br"),r._v("\ns.pop();"),t("br"),r._v("\n}"),t("br"),r._v("\n}")]),r._v(" "),t("h3",{attrs:{id:"dfs-与-bfs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dfs-与-bfs"}},[r._v("#")]),r._v(" DFS 与 BFS")]),r._v(" "),t("p",[r._v("DFS 与 BFS 的知识点我压缩在了一张思维导图里：")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/Cgp9HWCeKxCAccrHAADkE8e9C7Y821-2d8263.png",alt:"Drawing 4.png"}})]),r._v(" "),t("p",[r._v("关于代码模板，你只需要掌握两个。")]),r._v(" "),t("h4",{attrs:{id:"dfs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dfs"}},[r._v("#")]),r._v(" DFS")]),r._v(" "),t("p",[r._v("通常而言，DFS 算法会用到两个模板，一个用于遍历，另一个用于收集符合条件的解。其中用于遍历的代码模板如下：")]),r._v(" "),t("p",[r._v("boolean vis[N];"),t("br"),r._v("\nvoid DFS(int start) {"),t("br"),r._v("\nif start == end {"),t("br"),r._v("\n     success = true"),t("br"),r._v("\n     return"),t("br"),r._v("\n}"),t("br"),r._v("\n// 遍历当前可以做出的选择"),t("br"),r._v("\nfor opt in getOptions(start) {"),t("br"),r._v("\n     if (vis[opt]) continue;"),t("br"),r._v("\n     vis[opt] = true;"),t("br"),r._v("\n     dfs(opt);"),t("br"),r._v("\n     if success {"),t("br"),r._v("\n         return;"),t("br"),r._v("\n     }"),t("br"),r._v("\n}"),t("br"),r._v("\n}")]),r._v(" "),t("p",[r._v("用于收集符合条件的解的代码模板如下：")]),r._v(" "),t("p",[r._v("void dfs(A,"),t("br"),r._v("\n        int start, /* start 表示出发点*/"),t("br"),r._v("\n        vis,  /* 记录每个点是否已经访问 "),t("em",[r._v("/"),t("br"),r._v("\n        path, /")]),r._v(" 路径*/"),t("br"),r._v("\n        answer/"),t("em",[r._v("存放最优的答案")]),r._v("/) {"),t("br"),r._v("\nfinal int N = A == null ? 0 : A.length;"),t("br"),r._v("\nif (状态满足要求) { // 是更好的解吗？"),t("br"),r._v("\nif (s better_than ans) {"),t("br"),r._v("\nans = s"),t("br"),r._v("\n}"),t("br"),r._v("\nreturn;"),t("br"),r._v("\n}"),t("br"),r._v("\nfor next in {start点的后继点} {"),t("br"),r._v("\nif !vis[next] {"),t("br"),r._v("\npath.append(next);"),t("br"),r._v("\nvis[next] = true;"),t("br"),r._v("\ndfs(A, next, vis, path, answer);"),t("br"),r._v("\npath.pop();"),t("br"),r._v("\nvis[next] = false;"),t("br"),r._v("\n}"),t("br"),r._v("\n}"),t("br"),r._v("\n}")]),r._v(" "),t("h4",{attrs:{id:"bfs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bfs"}},[r._v("#")]),r._v(" BFS")]),r._v(" "),t("p",[r._v("巧合的是，BFS 也有两种写法，一种是使用队列，另一种是使用“两段击”。其中使用队列的代码写法如下：")]),r._v(" "),t("p",[r._v("bfs(s) { // s表示出发点"),t("br"),r._v("\nq = new queue()"),t("br"),r._v("\nq.push(s), visited[s] = true // 标记s为已访问"),t("br"),r._v("\nwhile (!q.empty()) {"),t("br"),r._v("\n   u = q.pop() // 拿到当前结点"),t("br"),r._v("\n   for next in getNext(u) { // 拿到u的后继next"),t("br"),r._v("\n     if (!visited[next]) { // 如果next还没有访问过"),t("br"),r._v("\n       q.push(next)"),t("br"),r._v("\n       visited[next] = true"),t("br"),r._v("\n     }"),t("br"),r._v("\n   }"),t("br"),r._v("\n}"),t("br"),r._v("\n}")]),r._v(" "),t("p",[r._v("使用“两段击”的代码写法如下：")]),r._v(" "),t("p",[r._v("bfs(s) { // s表示出发点"),t("br"),r._v("\ncur = {s};"),t("br"),r._v("\nvisited[s] = true; // 标记s为已访问"),t("br"),r._v("\nwhile (!cur.empty()) {"),t("br"),r._v("\n   next = [];"),t("br"),r._v("\n   for c in cur {"),t("br"),r._v("\n     for next in getNext(c) {"),t("br"),r._v("\n       if (!visited[next]) { // 如果next还没有访问过"),t("br"),r._v("\n         next.append(next);"),t("br"),r._v("\n         visited[next] = true;"),t("br"),r._v("\n       }"),t("br"),r._v("\n     }"),t("br"),r._v("\n   }"),t("br"),r._v("\n   cur = next;"),t("br"),r._v("\n}"),t("br"),r._v("\n}")]),r._v(" "),t("h3",{attrs:{id:"动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[r._v("#")]),r._v(" 动态规划")]),r._v(" "),t("p",[r._v("动态规划其实并没有太多的模板可以套，你需要通过实战练习不停地提高自己的应对能力。掌握动态规划的重点在于 6 步分析法，如下图所示：")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/CioPOWCeKxyAAzKlAADATI1rcXE081-83ebd2.png",alt:"Drawing 5.png"}})]),r._v(" "),t("p",[r._v("这里我们重点看一下需要你熟练掌握的 KMP 算法模板（你还记得求 next 数组时的动态规划吗？），如下所示：")]),r._v(" "),t("p",[r._v("int[] buildNext(String sub) {"),t("br"),r._v("\nfinal int N = sub == null ? 0 : sub.length();"),t("br"),r._v("\nint[] next = new int[N + 1];"),t("br"),r._v("\nint i = 0;"),t("br"),r._v("\nint j = -1;"),t("br"),r._v("\nnext[0] = -1;"),t("br"),r._v("\nwhile (i < N) {"),t("br"),r._v("\n   if (j == -1 || sub.charAt(i) == sub.charAt(j)) {"),t("br"),r._v("\n     i++;"),t("br"),r._v("\n     j++;"),t("br"),r._v("\n     if (i < sub.length() && j < sub.length() &&"),t("br"),r._v("\n         sub.charAt(i) == sub.charAt(j)) {"),t("br"),r._v("\n       next[i] = next[j];"),t("br"),r._v("\n     } else {"),t("br"),r._v("\n       next[i] = j;"),t("br"),r._v("\n     }"),t("br"),r._v("\n   } else {"),t("br"),r._v("\n     j = next[j];"),t("br"),r._v("\n   }"),t("br"),r._v("\n}"),t("br"),r._v("\nreturn next;"),t("br"),r._v("\n}"),t("br"),r._v("\nint KMP(String main, String sub) {"),t("br"),r._v("\nint i = 0;"),t("br"),r._v("\nint j = 0;"),t("br"),r._v("\nfinal int alen = main.length();"),t("br"),r._v("\nfinal int blen = sub.length();"),t("br"),r._v("\nint[] next = buildNext(sub);"),t("br"),r._v("\nwhile (i < alen && j < blen) {"),t("br"),r._v("\n   if (-1 == j || main.charAt(i) == sub.charAt(j)) {"),t("br"),r._v("\n     // 如果匹配成功，那么向前走"),t("br"),r._v("\n     // 这里和暴力的方法没有区别"),t("br"),r._v("\n     i++;"),t("br"),r._v("\n     j++;"),t("br"),r._v("\n   } else {"),t("br"),r._v("\n     j = next[j];"),t("br"),r._v("\n   }"),t("br"),r._v("\n}"),t("br"),r._v("\n// 看一下是不是匹配完了"),t("br"),r._v("\nreturn j == blen ? i - blen : -1;"),t("br"),r._v("\n}")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F15.StrStr%2F28.%E5%AE%9E%E7%8E%B0-str-str.kmp2.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F15.StrStr%2F28.%E5%AE%9E%E7%8E%B0-str-str.kmp2.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F15.StrStr%2F28.%E5%AE%9E%E7%8E%B0-str-str.kmp2.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[r._v("#")]),r._v(" 总结")]),r._v(" "),t("p",[r._v("整理好算法的代码模板之后，最后我再强调一点，也是新手往往容易犯错的地方。")]),r._v(" "),t("p",[r._v("不要试图把刷过的所有题都放到代码模板中，因为你复习的时候容易没有重点。另外，人的记忆能力是有限的，如果你强记一段代码，可能效果并不好。更重要的是勤于将知识进行整理、归纳以及压缩。然后将它们打包成知识库中的“积木”，在需要的时候直接拿来用，而不是再从 0 到 1 推导。")])])}),[],!1,null,null,null);t.default=v.exports}}]);