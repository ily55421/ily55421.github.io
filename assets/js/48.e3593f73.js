(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{646:function(a,n,s){"use strict";s.r(n);var e=s(0),t=Object(e.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"_02-java的基本类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_02-java的基本类型"}},[a._v("#")]),a._v(" 02 | Java的基本类型")]),a._v(" "),n("p",[a._v("如果你了解面向对象语言的发展史，那你可能听说过 Smalltalk 这门语言。它的影响力之大，以至于之后诞生的面向对象语言，或多或少都借鉴了它的设计和实现。")]),a._v(" "),n("p",[a._v("在 Smalltalk 中，所有的值都是对象。因此，许多人认为它是一门纯粹的面向对象语言。")]),a._v(" "),n("p",[a._v("Java 则不同，它引进了八个基本类型，来支持数值计算。Java 这么做的原因主要是工程上的考虑，因为使用基本类型能够在执行效率以及内存使用两方面提升软件性能。")]),a._v(" "),n("p",[a._v("今天，我们就来了解一下基本类型在 Java 虚拟机中的实现。")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('\npublic class Foo {\n\n  public static void main(String[] args) {\n\n    boolean 吃过饭没 = 2; // 直接编译的话 javac 会报错\n\n    if (吃过饭没) System.out.println(" 吃了 ");\n\n    if (true == 吃过饭没) System.out.println(" 真吃了 ");\n\n  }\n\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br")]),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br")])]),n("p",[a._v("在上一篇结尾的小作业里，我构造了这么一段代码，它将一个 boolean 类型的局部变量赋值为 2。为了方便记忆，我们给这个变量起个名字，就叫“吃过饭没”。")]),a._v(" "),n("p",[a._v("赋值语句后边我设置了两个看似一样的 if 语句。第一个 if 语句，也就是直接判断“吃过饭没”，在它成立的情况下，代码会打印“吃了”。")]),a._v(" "),n("p",[a._v("第二个 if 语句，也就是判断“吃过饭没”和 true 是否相等，在它成立的情况下，代码会打印“真吃了”。")]),a._v(" "),n("p",[a._v("当然，直接编译这段代码，编译器是会报错的。所以，我迂回了一下，采用一个 Java 字节码的汇编工具，直接对字节码进行更改。")]),a._v(" "),n("p",[a._v("那么问题就来了：当一个 boolean 变量的值是 2 时，它究竟是 true 还是 false 呢？")]),a._v(" "),n("p",[a._v("如果你跑过这段代码，你会发现，问虚拟机“吃过饭没”，它会回答“吃了”，而问虚拟机“真（==）吃过饭没”，虚拟机则不会回答“真吃了”。")]),a._v(" "),n("p",[a._v("那么虚拟机到底吃过没，下面我们来一起分析一下这背后的细节。")]),a._v(" "),n("h2",{attrs:{id:"java-虚拟机的-boolean-类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java-虚拟机的-boolean-类型"}},[a._v("#")]),a._v(" Java 虚拟机的 boolean 类型")]),a._v(" "),n("p",[a._v("首先，我们来看看 Java 语言规范以及 Java 虚拟机规范是怎么定义 boolean 类型的。")]),a._v(" "),n("p",[a._v("在 Java 语言规范中，boolean 类型的值只有两种可能，它们分别用符号“true”和“false”来表示。显然，这两个符号是不能被虚拟机直接使用的。")]),a._v(" "),n("p",[a._v("在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。这个编码规则约束了 Java 字节码的具体实现。")]),a._v(" "),n("p",[a._v("举个例子，对于存储 boolean 数组的字节码，Java 虚拟机需保证实际存入的值是整数 1 或者 0。")]),a._v(" "),n("p",[a._v("Java 虚拟机规范同时也要求 Java 编译器遵守这个编码规则，并且用整数相关的字节码来实现逻辑运算，以及基于 boolean 类型的条件跳转。这样一来，在编译而成的 class 文件中，除了字段和传入参数外，基本看不出 boolean 类型的痕迹了。")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('\n# Foo.main 编译后的字节码\n\n 0: iconst_2       // 我们用 AsmTools 更改了这一指令\n\n 1: istore_1\n\n 2: iload_1\n\n 3: ifeq 14        // 第一个 if 语句，即操作数栈上数值为 0 时跳转\n\n 6: getstatic java.lang.System.out\n\n 9: ldc " 吃了 "\n\n11: invokevirtual java.io.PrintStream.println\n\n14: iload_1\n\n15: iconst_1\n\n16: if_icmpne 27   // 第二个 if 语句，即操作数栈上两个数值不相同时跳转\n\n19: getstatic java.lang.System.out\n\n22: ldc " 真吃了 "\n\n24: invokevirtual java.io.PrintStream.println\n\n27: return\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br"),n("span",{staticClass:"line-number"},[a._v("28")]),n("br"),n("span",{staticClass:"line-number"},[a._v("29")]),n("br"),n("span",{staticClass:"line-number"},[a._v("30")]),n("br")]),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br"),n("span",{staticClass:"line-number"},[a._v("28")]),n("br"),n("span",{staticClass:"line-number"},[a._v("29")]),n("br"),n("span",{staticClass:"line-number"},[a._v("30")]),n("br")])]),n("p",[a._v("在前面的例子中，第一个 if 语句会被编译成条件跳转字节码 ifeq，翻译成人话就是说，如果局部变量“吃过饭没”的值为 0，那么跳过打印“吃了”的语句。")]),a._v(" "),n("p",[a._v("而第二个 if 语句则会被编译成条件跳转字节码 if_icmpne，也就是说，如果局部变量的值和整数 1 不相等，那么跳过打印“真吃了”的语句。")]),a._v(" "),n("p",[a._v("可以看到，Java 编译器的确遵守了相同的编码规则。当然，这个约束很容易绕开。除了我们小作业中用到的汇编工具 AsmTools 外，还有许多可以修改字节码的 Java 库，比如说 ASM ["),n("a",{attrs:{href:"https://asm.ow2.io/",target:"_blank",rel:"noopener noreferrer"}},[a._v("1] "),n("OutboundLink")],1),a._v("等。")]),a._v(" "),n("p",[a._v("对于 Java 虚拟机来说，它看到的 boolean 类型，早已被映射为整数类型。因此，将原本声明为 boolean 类型的局部变量，赋值为除了 0、1 之外的整数值，在 Java 虚拟机看来是“合法”的。")]),a._v(" "),n("p",[a._v("在我们的例子中，经过编译器编译之后，Java 虚拟机看到的不是在问“吃过饭没”，而是在问“吃过几碗饭”。也就是说，第一个 if 语句变成：你不会一碗饭都没吃吧。第二个 if 语句则变成：你吃过一碗饭了吗。")]),a._v(" "),n("p",[a._v("如果我们约定俗成，每人每顿只吃一碗，那么第二个 if 语句还是有意义的。但如果我们打破常规，吃了两碗，那么较真的 Java 虚拟机就会将第二个 if 语句判定为假了。")]),a._v(" "),n("h2",{attrs:{id:"java-的基本类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java-的基本类型"}},[a._v("#")]),a._v(" Java 的基本类型")]),a._v(" "),n("p",[a._v("除了上面提到的 boolean 类型外，Java 的基本类型还包括整数类型 byte、short、char、int 和 long，以及浮点类型 float 和 double。")]),a._v(" "),n("p",[n("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/05/31/image-20220531133236379-10e288.png",alt:"image-20220531133236379"}})]),a._v(" "),n("p",[a._v("Java 的基本类型都有对应的值域和默认值。可以看到，byte、short、int、long、float 以及 double  的值域依次扩大，而且前面的值域被后面的值域所包含。因此，从前面的基本类型转换至后面的基本类型，无需强制转换。另外一点值得注意的是，尽管他们的默认值看起来不一样，但在内存中都是 0。")]),a._v(" "),n("p",[a._v("在这些基本类型中，boolean 和 char 是唯二的无符号类型。在不考虑违反规范的情况下，boolean 类型的取值范围是 0 或者  1。char 类型的取值范围则是 [0, 65535]。通常我们可以认定 char 类型的值为非负数。这种特性十分有用，比如说作为数组索引等。")]),a._v(" "),n("p",[a._v("在前面的例子中，我们能够将整数 2 存储到一个声明为 boolean 类型的局部变量中。那么，声明为 byte、char 以及 short 的局部变量，是否也能够存储超出它们取值范围的数值呢？")]),a._v(" "),n("p",[a._v("答案是可以的。而且，这些超出取值范围的数值同样会带来一些麻烦。比如说，声明为 char 类型的局部变量实际上有可能为负数。当然，在正常使用 Java 编译器的情况下，生成的字节码会遵守 Java 虚拟机规范对编译器的约束，因此你无须过分担心局部变量会超出它们的取值范围。")]),a._v(" "),n("p",[a._v("Java 的浮点类型采用 IEEE 754 浮点数格式。以 float 为例，浮点类型通常有两个 0，+0.0F 以及 -0.0F。")]),a._v(" "),n("p",[a._v("前者在 Java 里是 0，后者是符号位为 1、其他位均为 0 的浮点数，在内存中等同于十六进制整数 0x8000000（即 -0.0F  可通过 Float.intBitsToFloat(0x8000000) 求得）。尽管它们的内存数值不同，但是在 Java 中 +0.0F ==  -0.0F 会返回真。")]),a._v(" "),n("p",[a._v("在有了 +0.0F 和 -0.0F 这两个定义后，我们便可以定义浮点数中的正无穷及负无穷。正无穷就是任意正浮点数（不包括 +0.0F）除以 +0.0F 得到的值，而负无穷是任意正浮点数除以 -0.0F 得到的值。在 Java  中，正无穷和负无穷是有确切的值，在内存中分别等同于十六进制整数 0x7F800000 和 0xFF800000。")]),a._v(" "),n("p",[a._v("你也许会好奇，既然整数 0x7F800000 等同于正无穷，那么 0x7F800001 又对应什么浮点数呢？")]),a._v(" "),n("p",[a._v("这个数字对应的浮点数是 NaN（Not-a-Number）。")]),a._v(" "),n("p",[a._v("不仅如此，[0x7F800001, 0x7FFFFFFF] 和 [0xFF800001, 0xFFFFFFFF] 对应的都是  NaN。当然，一般我们计算得出的 NaN，比如说通过 +0.0F/+0.0F，在内存中应为 0x7FC00000。这个数值，我们称之为标准的  NaN，而其他的我们称之为不标准的 NaN。")]),a._v(" "),n("p",[a._v("NaN 有一个有趣的特性：除了“!=”始终返回 true 之外，所有其他比较结果都会返回 false。")]),a._v(" "),n("p",[a._v("举例来说，“NaN<1.0F”返回 false，而“NaN>=1.0F”同样返回 false。对于任意浮点数 f，不管它是 0 还是 NaN，“f!=NaN”始终会返回 true，而“f==NaN”始终会返回 false。")]),a._v(" "),n("p",[a._v("因此，我们在程序里做浮点数比较的时候，需要考虑上述特性。在本专栏的第二部分，我会介绍这个特性给向量化比较带来什么麻烦。")]),a._v(" "),n("h2",{attrs:{id:"java-基本类型的大小"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java-基本类型的大小"}},[a._v("#")]),a._v(" Java 基本类型的大小")]),a._v(" "),n("p",[a._v("在第一篇中我曾经提到，Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。为了方便理解，这里我只讨论供解释器使用的解释栈帧（interpreted frame）。")]),a._v(" "),n("p",[a._v("这种栈帧有两个主要的组成部分，分别是局部变量区，以及字节码的操作数栈。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的“this 指针”以及方法所接收的参数。")]),a._v(" "),n("p",[a._v("在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。")]),a._v(" "),n("p",[a._v("也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。")]),a._v(" "),n("p",[a._v("当然，这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合。")]),a._v(" "),n("p",[a._v("因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把  0xFFFFFFFF（-1）存储到一个声明为 char  类型的字段里时，由于该字段仅占两字节，所以高两位的字节便会被截取掉，最终存入“\\uFFFF”。")]),a._v(" "),n("p",[a._v("boolean 字段和 boolean 数组则比较特殊。在 HotSpot 中，boolean 字段占用一字节，而 boolean  数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot  在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。")]),a._v(" "),n("p",[a._v("讲完了存储，现在我来讲讲加载。Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。")]),a._v(" "),n("p",[a._v("对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。")]),a._v(" "),n("p",[a._v("对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short  的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为 0，那么该 int 类型的值的高二字节会用 0  来填充，否则用 1 来填充。")]),a._v(" "),n("h2",{attrs:{id:"总结与实践"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结与实践"}},[a._v("#")]),a._v(" 总结与实践")]),a._v(" "),n("p",[a._v("今天我介绍了 Java 里的基本类型。")]),a._v(" "),n("p",[a._v("其中，boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为 0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。")]),a._v(" "),n("p",[a._v("除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑 +0.0F、-0.0F 以及 NaN 的情况。")]),a._v(" "),n("p",[a._v("除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但它们在堆中占用的大小确不同。在将  boolean、byte、char 以及 short 的值存入字段或者数组单元时，Java 虚拟机会进行掩码操作。在读取时，Java  虚拟机则会将其扩展为 int 类型。")]),a._v(" "),n("p",[a._v("今天的动手环节，你可以观测一下，将 boolean 类型的值存入字段中时，Java 虚拟机所做的掩码操作。")]),a._v(" "),n("p",[a._v("你可以将下面代码中 boolValue = true 里的 true 换为 2 或者 3，看看打印结果与你的猜测是否相符合。")]),a._v(" "),n("p",[a._v("熟悉 Unsafe 的同学，可以使用 Unsafe.putBoolean 和 Unsafe.putByte 方法，看看还会不会做掩码操作。")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('\npublic class Foo {\n\n  static boolean boolValue;\n\n  public static void main(String[] args) {\n\n    boolValue = true; // 将这个 true 替换为 2 或者 3，再看看打印结果\n\n    if (boolValue) System.out.println("Hello, Java!");\n\n    if (boolValue == true) System.out.println("Hello, JVM!");\n\n  }\n\n}\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br")]),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br")])]),n("h2",{attrs:{id:"精选留言-79"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#精选留言-79"}},[a._v("#")]),a._v(" 精选留言(79)")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("丨落灬小莫")]),a._v(" "),n("p",[a._v("2018-07-23")]),a._v(" "),n("p",[a._v("138")]),a._v(" "),n("p",[a._v("当替换为2的时候无输出\n当替换为3的时候打印HelloJava及HelloJVM\n猜测是因为将boolean 保存在静态域中,指定了其类型为'Z',当修改为2时取低位最后一位为0,当修改为3时取低位最后一位为1\n则说明boolean的掩码处理是取低位的最后一位")]),a._v(" "),n("p",[a._v("作者回复: 对的！")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("金蝉子")]),a._v(" "),n("p",[a._v("2018-07-23")]),a._v(" "),n("p",[a._v("30")]),a._v(" "),n("p",[a._v("老师可以讲下ASM、Unsafe和CAS的底层原理吗？这块儿一直是个拦路虎，谢谢！")]),a._v(" "),n("p",[a._v("作者回复: ASM你指的是那个字节码工程包吗？是的话那就是一个提供了字节码抽象的工具，允许用Java代码来生成或者更改字节码。JDK里也会用到ASM，用来生成一些适配器什么的。我印象中代码覆盖工具JaCoCo也是用ASM来实现的。")]),a._v(" "),n("p",[a._v("Unsafe就是一些不被虚拟机控制的内存操作的合集。具体想要了解哪个API？")]),a._v(" "),n("p",[a._v("CAS可以理解为原子性的写操作，这个概念来自于底层CPU指令。Unsafe提供了一些cas的Java接口，在即时编译器中我们会将对这些接口的调用替换成具体的CPU指令。")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("东方")]),a._v(" "),n("p",[a._v("2018-07-23")]),a._v(" "),n("p",[a._v("25")]),a._v(" "),n("p",[a._v("Unsafe.putBoolean和Unsafe.puByte是native实现")]),a._v(" "),n("p",[a._v("putBoolean和putByte也是通过宏SET_FIELD模板出的函数")]),a._v(" "),n("p",[a._v("#define SET_FIELD(obj, offset, type_name, x) "),n("br"),a._v("\noop p = JNIHandles::resolve(obj); "),n("br"),a._v(" "),n("em",[a._v("(type_name")]),a._v(")index_oop_from_field_offset_long(p, offset) = truncate_##type_name(x)")]),a._v(" "),n("p",[a._v("unsafe.cpp中定义宏做truncate\n#define truncate_jboolean(x) ((x) & 1)\n#define truncate_jbyte(x) (x)\n#define truncate_jshort(x) (x)\n#define truncate_jchar(x) (x)\n#define truncate_jint(x) (x)\n#define truncate_jlong(x) (x)\n#define truncate_jfloat(x) (x)\n#define truncate_jdouble(x) (x)")]),a._v(" "),n("p",[a._v("综上：unsafe.Put*不会对值做修改\n------------------------------------------------------------------------------------\ngetBoolean和getByte也是通过宏GET_FIELD模板出的函数")]),a._v(" "),n("p",[a._v("#define GET_FIELD(obj, offset, type_name, v) "),n("br"),a._v("\noop p = JNIHandles::resolve(obj); "),n("br"),a._v("\ntype_name v = "),n("em",[a._v("(type_name")]),a._v(")index_oop_from_field_offset_long(p, offset)")]),a._v(" "),n("p",[a._v("综上，unsafe.Get*不会对值做修改\n------------------------------------------------------------------------------------\n验证：\nunsafe.putByte(foo, addr, (byte)2); // 设置为: 2\nSystem.out.println(unsafe.getByte(foo, addr)); // 打印getByte: 2\nSystem.out.println(unsafe.getBoolean(foo, addr)); // 打印getBoolean: true")]),a._v(" "),n("p",[a._v('unsafe.putByte(foo, addr, (byte)1); // 设置为: 1\nSystem.out.println(unsafe.getByte(foo, addr)); // 打印getByte: 1\nSystem.out.println(unsafe.getBoolean(foo, addr)); // 打印getBoolean: true\n------------------------------------------------------------------------------------\n疑问：\nif(foo.flag)判断，使用getfield  Field flag:"Z"，执行逻辑等于：0 ！= flag\nif(foo.getFlag())判断，使用invokevirtual  Method getFlag:"()Z"，执行逻辑等于： 0 != （(flag) & 1）')]),a._v(" "),n("p",[a._v("求大神帮忙解答")]),a._v(" "),n("p",[a._v('--------------------------\n附getFlag jasm码：\npublic Method getFlag:"()Z"\nstack 1 locals 1\n{\naload_0;\ngetfield  Field flag:"Z";\nireturn;\n}')]),a._v(" "),n("p",[a._v("https://gist.github.com/qudongfang/49635d86882c03e49cff2b0f7d833805")]),a._v(" "),n("p",[a._v("作者回复: 研究得非常深入！")]),a._v(" "),n("p",[a._v("Unsafe.putBoolean会做掩码，另外方法返回也会对boolean byte char short进行掩码")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("追梦")]),a._v(" "),n("p",[a._v("2018-10-21")]),a._v(" "),n("p",[a._v("15")]),a._v(" "),n("p",[a._v("有个地方初看不易看懂，我来解释下：\n作者一开始放的“吃没吃饭”的例子中boolean变量是局部变量，存放在Java方法栈的栈帧中的局部变量区，占据一个数据单元，无需做掩码；最后的例子中boolean变量是成员变量，存储在堆中的对象实例里，占有一个字节，且需要对最后一位做掩码")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("Kyle")]),a._v(" "),n("p",[a._v("2018-07-23")]),a._v(" "),n("p",[a._v("15")]),a._v(" "),n("p",[a._v("老师，文中看你说到：\n“也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4  个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。”")]),a._v(" "),n("p",[a._v("但是我记得boolean在内存中占1字节，char占2字节，这里是什么个意思？")]),a._v(" "),n("p",[a._v("作者回复: 你说的是在堆里的情况。在解释器栈上是不一样的。至于原因吗，主要是变长数组不好控制，所以就选择浪费一些空间，以便访问时直接通过下标来计算地址。")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("Geek_dde3a...")]),a._v(" "),n("p",[a._v("2018-07-23")]),a._v(" "),n("p",[a._v("12")]),a._v(" "),n("p",[a._v("你好，在内存中都是0，那么是如何区别是哪种类型数据的呢？")]),a._v(" "),n("p",[a._v("作者回复: 内存中是不做区分的。Java程序想要把它解读成什么类型，它就是什么类型。")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("life is ...")]),a._v(" "),n("p",[a._v("2018-09-14")]),a._v(" "),n("p",[a._v("9")]),a._v(" "),n("p",[a._v("老师你好，我刚来订阅，所以才开始看。\n有一个疑问，您的原文“因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8  个字节。”。但是有一句话，java一次编译，到处运行。计算机位数不一样的话，导致一样类型的size不一样，还可以到处运行吗？这里指的到处运行，是不是需要同位啊？比如32位的编译只能在32位的机器上运行，64只能在64的上运行。能互相兼容运行嘛？")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("午夜的汽笛")]),a._v(" "),n("p",[a._v("2018-09-12")]),a._v(" "),n("p",[a._v("9")]),a._v(" "),n("p",[a._v("这节看的很吃力，对什么掩码，子码，反码，补码都换给大学老师了。")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("落叶飞逝的...")]),a._v(" "),n("p",[a._v("2018-07-24")]),a._v(" "),n("p",[a._v("8")]),a._v(" "),n("p",[a._v("其实那个boolean的true虚拟机里面为1，也就是if(true==吃了没)其实可以替换成if(1==2)这样理解吧")]),a._v(" "),n("p",[a._v("作者回复: 对的！")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("dong")]),a._v(" "),n("p",[a._v("2018-07-27")]),a._v(" "),n("p",[a._v("7")]),a._v(" "),n("p",[a._v('感觉"吃饭了"例子，弄得有点饶了。也有些地方语句的起承转合不是很通顺，个人理解。')]),a._v(" "),n("p",[a._v("作者回复: 谢谢建议")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("andy")]),a._v(" "),n("p",[a._v("2018-09-13")]),a._v(" "),n("p",[a._v("6")]),a._v(" "),n("p",[a._v("我替换成2和3,都只能打印出一个Hello Java为什么呢？下面是AsmTools反编译代码\nsuper public class Foo\nversion 52:0\n{")]),a._v(" "),n("p",[a._v("static Field boolValue:Z;")]),a._v(" "),n("p",[a._v('public Method "'),n("init",[a._v('":"()V"\nstack 1 locals 1\n{\naload_0;\ninvokespecial   Method java/lang/Object."'),n("init",[a._v('":"()V";\nreturn;\n}')])],1)],1),a._v(" "),n("p",[a._v('public static Method main:"([Ljava/lang/String;)V"\nstack 2 locals 1\n{\niconst_2;\nputstatic       Field boolValue:"Z";\ngetstatic       Field boolValue:"Z";\nifeq    L18;\ngetstatic       Field java/lang/System.out:"Ljava/io/PrintStream;";\nldc     String "Hello, Java!";\ninvokevirtual   Method java/io/PrintStream.println:"(Ljava/lang/String;)V";\nL18:    stack_frame_type same;\ngetstatic       Field boolValue:"Z";\niconst_1;\nif_icmpne       L33;\ngetstatic       Field java/lang/System.out:"Ljava/io/PrintStream;";\nldc     String "Hello, JVM!";\ninvokevirtual   Method java/io/PrintStream.println:"(Ljava/lang/String;)V";\nL33:    stack_frame_type same;\nreturn;\n}')]),a._v(" "),n("p",[a._v("} // end Class Foo")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("杨春鹏")]),a._v(" "),n("p",[a._v("2018-07-26")]),a._v(" "),n("p",[a._v("6")]),a._v(" "),n("p",[a._v("局部变量中基本数据类型存储在栈中，变量的变量名(引用符号)和变量值(字面量)都存储在栈中。\n局部变量中引用数据类型的引用地址存储在栈中，对象的实例数据存储在堆中，类型数据存储在方法区\n全局变量的基本数据类型和引用数据类型，都存储在堆中。\n不知理解的是否正确")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("Invincible...")]),a._v(" "),n("p",[a._v("2018-11-29")]),a._v(" "),n("p",[a._v("5")]),a._v(" "),n("p",[a._v("为什么我不能让boolvalue＝2或者3……")]),a._v(" "),n("p",[a._v("作者回复: 因为javac不支持这种操作，它把boolean是用int实现的这种虚拟机的实现细节给隐藏起来了，从而使得在语言层面没有这种会引起歧义的值。")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("志远")]),a._v(" "),n("p",[a._v("2018-07-23")]),a._v(" "),n("p",[a._v("4")]),a._v(" "),n("p",[a._v("NaN 有一个有趣的特性：除了“!= 始终返回 true”之外，所有其他比较结果都会返回 false。这句话好拗口啊，双引号的标点符号有问题吧")]),a._v(" "),n("p",[a._v("作者回复: 多谢指出！应该是 “!=“")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("梧桐树")]),a._v(" "),n("p",[a._v("2018-07-26")]),a._v(" "),n("p",[a._v("3")]),a._v(" "),n("p",[a._v("如果64位处理器，long 和double和其它类型一样都是8个字节码在栈中")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("沉淀的梦想")]),a._v(" "),n("p",[a._v("2018-07-25")]),a._v(" "),n("p",[a._v("3")]),a._v(" "),n("p",[a._v("为什么我替换成2和3，但是现象和第一讲的时候一样呢？都只能打印出一个Hello Java，我反复检查也没发现什么问题，这有可能是什么原因呢？")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("daybreak")]),a._v(" "),n("p",[a._v("2018-12-25")]),a._v(" "),n("p",[a._v("2")]),a._v(" "),n("p",[a._v("你好，我一点不理解。为什么“吃过饭没”的值为0时跳转，不应该值为1时跳转吗？")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("Arvin")]),a._v(" "),n("p",[a._v("2018-10-18")]),a._v(" "),n("p",[a._v("2")]),a._v(" "),n("p",[a._v("当改为2或者3时则出现编译错误是则么回事！！！！")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("crystal")]),a._v(" "),n("p",[a._v("2018-08-27")]),a._v(" "),n("p",[a._v("2")]),a._v(" "),n("p",[a._v("老师，有个问题请教:第一个例子将过饭没改为2,会输出吃过了；第二个例子将boolValue改为2，却不输出信息。两个变量值都是2,为什么输出的结果会不同？")]),a._v(" "),n("ul",[n("li")]),a._v(" "),n("p",[a._v("Ennis LM")]),a._v(" "),n("p",[a._v("2018-07-28")]),a._v(" "),n("p",[a._v("2")]),a._v(" "),n("p",[a._v("因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。\n为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。")]),a._v(" "),n("p",[a._v("为什么一个是隐式一个是显式")])])}),[],!1,null,null,null);n.default=t.exports}}]);