(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{615:function(r,t,n){"use strict";n.r(t);var e=n(0),a=Object(e.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"数据结构模板"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构模板"}},[r._v("#")]),r._v(" 数据结构模板")]),r._v(" "),t("p",[r._v("在这个模块，我把常见的“套路”题，帮你总结成手写代码时应该准备的各种代码模板。还会把自己压箱底的"),t("strong",[r._v("独家代码模板")]),r._v("分享给你，利用它，我多次在 10 分钟以内拿下了算法面试。")]),r._v(" "),t("p",[r._v("今天我先带你把数据结构部分做一个归纳和整理，"),t("strong",[r._v("方便你考前复习和平日积累")]),r._v("。可以想象一下，如果在准备面试期间，你已经刷了很多题，那么在临近面试时还可以做些什么呢？")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("把所有写过的代码再看一遍？")])]),r._v(" "),t("li",[t("p",[r._v("把前面 20 讲的内容从头到尾再复习一遍？")])]),r._v(" "),t("li",[t("p",[r._v("还是继续刷题？")])])]),r._v(" "),t("p",[r._v("在我个人看来，以上这些方法都不可取，此时最行之有效的方法是将学过的知识尽可能地压缩、再压缩，最后形成模板。整理模板，有以下几个好处。")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("组合：其实大部分面试题都是一些算法模块的组合，并不需要我们真正去发明一个算法。")])]),r._v(" "),t("li",[t("p",[r._v("速度：面试写题时速度更快，一些常用的功能性代码可以直接粘贴过去，不用在打字和调试上浪费时间。")])]),r._v(" "),t("li",[t("p",[r._v("重点：可以在有限的时间里重点关注整理好的代码模板，告别“大海捞针”式的复习。")])])]),r._v(" "),t("p",[r._v("其实面试中考察的那些高频知识点，就像一块块“积木”，而面试求解过程就像“搭积木的游戏”。高效利用代码模版的技巧，能够帮助你在面试时写出更高效和 0 Bug 的代码。")]),r._v(" "),t("blockquote",[t("p",[r._v("说明：一些扩展知识点，我会通过练习题的形式给出来。")])]),r._v(" "),t("h3",{attrs:{id:"栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[r._v("#")]),r._v(" 栈")]),r._v(" "),t("p",[r._v("在"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6690%26fileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("《01 | 栈：从简单栈到单调栈，解决经典栈问题》"),t("OutboundLink")],1),r._v("中，我们将栈的知识总结在了下面这张知识导图中。")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/CioPOWCbkq2AF_S-AAHp6R0E_i8993-217278.png",alt:"Drawing 0.png"}})]),r._v(" "),t("h4",{attrs:{id:"简单栈的性质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单栈的性质"}},[r._v("#")]),r._v(" 简单栈的性质")]),r._v(" "),t("p",[r._v("后面我们又在"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6709%26fileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("《20 | 5 种解法，如何利用常量空间求解最长有效括号长度？》"),t("OutboundLink")],1),r._v("的“特点 4”中，介绍了另一个栈的重点性质——"),t("strong",[r._v("括号匹配时栈的性质")]),r._v("。我们可以用如下代码模板展示这个性质：")]),r._v(" "),t("p",[r._v("int longestValidParentheses(String s) {"),t("br"),r._v("\n   final int N = s == null ? 0 : s.length();"),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("if")]),r._v(" (N <= "),t("span",{staticClass:"hljs-number"},[r._v("1")]),r._v(") {"),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("return")]),r._v(" "),t("span",{staticClass:"hljs-number"},[r._v("0")]),r._v(";"),t("br"),r._v("\n}"),t("br"),r._v("\n​"),t("br"),r._v("\nStack<Integer> st = "),t("span",{staticClass:"hljs-keyword"},[r._v("new")]),r._v(" Stack<>();"),t("br"),r._v("\n​"),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 最长的有效长度")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("int")]),r._v(" ans = "),t("span",{staticClass:"hljs-number"},[r._v("0")]),r._v(";"),t("br"),r._v("\n​"),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("int")]),r._v(" start = "),t("span",{staticClass:"hljs-number"},[r._v("0")]),r._v(";"),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("for")]),r._v(" ("),t("span",{staticClass:"hljs-keyword"},[r._v("int")]),r._v(" i = "),t("span",{staticClass:"hljs-number"},[r._v("0")]),r._v("; i < N; i++) {"),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("final")]),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("char")]),r._v(" c = s.charAt(i);"),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("if")]),r._v(" (c == "),t("span",{staticClass:"hljs-string"},[r._v("')'")]),r._v(") {"),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 如果从[start, i]这个区间里面")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 右括号已经可以匹配掉所有的左括号了")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("if")]),r._v(" (st.isEmpty()) {"),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 问题2:更新新字符串的开头")]),t("br"),r._v("\n     start = i + "),t("span",{staticClass:"hljs-number"},[r._v("1")]),r._v(";"),t("br"),r._v("\n   } "),t("span",{staticClass:"hljs-keyword"},[r._v("else")]),r._v(" {"),t("br"),r._v("\n     st.pop();"),t("br"),r._v(" "),t("span",{staticClass:"hljs-comment"},[r._v("// 注意问题1，3在这里统一处理")]),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("final")]),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("int")]),r._v(" base ="),t("br"),r._v("\n         st.isEmpty() ? start : st.peek() + "),t("span",{staticClass:"hljs-number"},[r._v("1")]),r._v(";"),t("br"),r._v("\n     ans = Math.max(ans, i - base + "),t("span",{staticClass:"hljs-number"},[r._v("1")]),r._v(");"),t("br"),r._v("\n   }"),t("br"),r._v("\n} "),t("span",{staticClass:"hljs-keyword"},[r._v("else")]),r._v(" { "),t("span",{staticClass:"hljs-comment"},[r._v("/* 如果字符是左括号 */")]),t("br"),r._v("\n   st.push(i);"),t("br"),r._v("\n}"),t("br"),r._v("\n} "),t("span",{staticClass:"hljs-comment"},[r._v("// end for")]),t("br"),r._v("\n​"),t("br"),r._v(" "),t("span",{staticClass:"hljs-keyword"},[r._v("return")]),r._v(" ans;"),t("br"),r._v("\n​"),t("br"),r._v("\n}"),t("br"),r._v("\n}")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F20.Braces%2F32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.stack.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F20.Braces%2F32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.stack.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F20.Braces%2F32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.stack.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[r._v("栈的模拟主要是使用其他数据结构来模拟栈的 push/pop 操作，主要涉及 3 个经典的题目，即下面的练习题 1、练习题 2 以及练习题 3。")]),r._v(" "),t("p",[t("strong",[r._v("练习题 1")]),r._v("：请使用两个队列实现栈的 push/pop/empty/size 四种操作。")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[t("strong",[r._v("练习题 2")]),r._v("：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F946.%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F946.%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F946.%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[t("strong",[r._v("练习题 3")]),r._v("：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F155.%E6%9C%80%E5%B0%8F%E6%A0%88.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F155.%E6%9C%80%E5%B0%8F%E6%A0%88.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F155.%E6%9C%80%E5%B0%8F%E6%A0%88.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("h4",{attrs:{id:"单调栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单调栈"}},[r._v("#")]),r._v(" 单调栈")]),r._v(" "),t("p",[r._v("单调栈中经常还会用来解决这类题目：数组中元素右边第一个比元素自身小的元素的位置。")]),r._v(" "),t("p",[r._v("int[] findRightSmall(int[] A) {"),t("br"),r._v("\n// 结果数组"),t("br"),r._v("\nint[] ans = new int[A.length];"),t("br"),r._v("\n// 注意，栈中的元素记录的是下标"),t("br"),r._v("\nStack"),t("Integer",[r._v(" t = new Stack();"),t("br"),r._v("\nfor (int i = 0; i < A.length; i++) {"),t("br"),r._v("\n   final int x = A[i];"),t("br"),r._v("\n   // 每个元素都向左遍历栈中的元素完成消除动作"),t("br"),r._v("\n   while (!t.empty() && A[t.peek()] > x) {"),t("br"),r._v("\n     // 消除的时候，记录一下被谁消除了"),t("br"),r._v("\n     ans[t.peek()] = i;"),t("br"),r._v("\n     // 消除时候，值更大的需要从栈中消失"),t("br"),r._v("\n     t.pop();"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 剩下的入栈"),t("br"),r._v("\n   t.push(i);"),t("br"),r._v("\n}"),t("br"),r._v("\n// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。"),t("br"),r._v("\nwhile (!t.empty()) {"),t("br"),r._v("\n   ans[t.peek()] = -1;"),t("br"),r._v("\n   t.pop();"),t("br"),r._v("\n}"),t("br"),r._v("\nreturn ans;"),t("br"),r._v("\n}")])],1),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2FExample03.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2FExample03.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2FExample03.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[r._v("还有 3 类问题与上面这道题目类似，一般而言，深入理解其中一个模板即可。")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("数组中元素右边第一个比我大的元素的位置")])]),r._v(" "),t("li",[t("p",[r._v("数组中元素左边离我最近且比我小的元素的位置")])]),r._v(" "),t("li",[t("p",[r._v("数组中元素左边离我最近且比我大的元素的位置")])])]),r._v(" "),t("h4",{attrs:{id:"单调栈的性质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单调栈的性质"}},[r._v("#")]),r._v(" 单调栈的性质")]),r._v(" "),t("p",[r._v("我们将单调栈的性质总结为以下两点，更详细的介绍你可以回到"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6705%26fileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("《16 | 如何利用 DP 与单调队列寻找最大矩形？》"),t("OutboundLink")],1),r._v("进行复习。")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("当单调递增栈中存放数组下标 i, j, k 时，其中 (i, k] 中的元素 > A[j]；")])]),r._v(" "),t("li",[t("p",[r._v("当单调递增栈中存放数组下标 i, j，并且当 A[k] 入栈，会把栈顶元素 A[j]“削”出栈时，其中 (j, k) 元素 > A[j]。")])])]),r._v(" "),t("p",[r._v("我们曾经用到单调栈性质的模板代码求解最大矩形，如下所示：")]),r._v(" "),t("p",[r._v("int largestRectangleArea(int[] A) {"),t("br"),r._v("\nfinal int N = A == null ? 0 : A.length;"),t("br"),r._v("\n// 虽然可以用Stack"),t("Integer",[r._v("，但是这里为了更快地操作，我们用"),t("br"),r._v("\n// 数组模拟栈来运行，因为我们知道最多存放的内容实际上就是N个"),t("br"),r._v("\nint top = 0;"),t("br"),r._v("\n// s[top-1]表示栈顶元素"),t("br"),r._v("\nint[] s = new int[N];"),t("br"),r._v("\nint ans = 0;"),t("br"),r._v("\n// 注意，这里我们取到了i == N"),t("br"),r._v("\n// 按理说，不应该取到i == N的。但是这时候主要是为了处理这种数组"),t("br"),r._v("\n// A = [1, 2, 3]"),t("br"),r._v("\n// 没有任何元素会出栈。"),t("br"),r._v("\n// 那么最后我们用一个0元素，把所有的元素都削出栈。"),t("br"),r._v("\n// 这样代码就可以统一处理掉。"),t("br"),r._v("\nfor (int i = 0; i <= N; i++) {"),t("br"),r._v("\n   // 注意：当i == N的时候，x = -1;"),t("br"),r._v("\n   // 比数组中的元素都要小。"),t("br"),r._v("\n   final int x = i == N ? -1 : A[i];"),t("br"),r._v("\n   while (top > 0 && A[s[top - 1]] > x) {"),t("br"),r._v("\n     // 计算以A[s[top]]的元素的高度的矩形。"),t("br"),r._v("\n     final int height = A[s[--top]];"),t("br"),r._v("\n     // i元素要将index = s[top-1]的元素出栈。"),t("br"),r._v("\n     // 那么根据性质2/3："),t("br"),r._v("\n     // 此时A[s[top-1] .... i) 这个区间里面的元素都是"),t("br"),r._v("\n     // 大于A[s[top-1]]的"),t("br"),r._v("\n     final int rightPos = i;"),t("br"),r._v("\n     // 这里需要使用性质1."),t("br"),r._v("\n     // 注意：当栈中一个元素都没有的时候，要取-1"),t("br"),r._v("\n     final int leftPos = top > 0 ? s[top - 1] : -1;"),t("br"),r._v("\n     final int width = rightPos - leftPos - 1;"),t("br"),r._v("\n     final int area = height * width;"),t("br"),r._v("\n     ans = Math.max(ans, area);"),t("br"),r._v("\n   }"),t("br"),r._v("\n   s[top++] = i;"),t("br"),r._v("\n}"),t("br"),r._v("\nreturn ans;"),t("br"),r._v("\n}")])],1),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2F84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2F84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2F84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("h3",{attrs:{id:"队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[r._v("#")]),r._v(" 队列")]),r._v(" "),t("p",[r._v("关于队列的知识点，我们同样总结在了一张思维导图中，如下所示：")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/CioPOWCbksmAJunlAAFTfMBlaiw597-a07e36.png",alt:"Drawing 1.png"}})]),r._v(" "),t("p",[r._v("队列的数据结构知识点一般有 5 个：")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("FIFO 队列")])]),r._v(" "),t("li",[t("p",[r._v("循环队列（模板）")])]),r._v(" "),t("li",[t("p",[r._v("单调队列（模板）")])]),r._v(" "),t("li",[t("p",[r._v("堆（模板）")])]),r._v(" "),t("li",[t("p",[r._v("优先级队列")])])]),r._v(" "),t("p",[r._v("不过一般而言，需要重点掌握的数据结构的模板只有 3 个，即循环队列、单调队列以及堆。")]),r._v(" "),t("h4",{attrs:{id:"循环队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#循环队列"}},[r._v("#")]),r._v(" 循环队列")]),r._v(" "),t("p",[r._v("首先我们看一下使用数组来实现循环队列的写法，代码如下：")]),r._v(" "),t("p",[r._v("class MyCircularQueue {"),t("br"),r._v("\n   // 已经使用的元素个数"),t("br"),r._v("\n   private int used = 0;"),t("br"),r._v("\n   // 第一个元素所在位置"),t("br"),r._v("\n   private int front = 0;"),t("br"),r._v("\n   // rear是enQueue可在存放的位置"),t("br"),r._v("\n   // 注意开闭原则"),t("br"),r._v("\n   // [front, rear)"),t("br"),r._v("\n   private int rear = 0;"),t("br"),r._v("\n   // 循环队列最多可以存放的元素个数"),t("br"),r._v("\n   private int capacity = 0;"),t("br"),r._v("\n   // 循环队列的存储空间"),t("br"),r._v("\n   private int[] a = null;"),t("br"),r._v("\n   public MyCircularQueue(int k) {"),t("br"),r._v("\n       // 初始化循环队列"),t("br"),r._v("\n       capacity = k;"),t("br"),r._v("\n       a = new int[capacity];"),t("br"),r._v("\n   }"),t("br"),r._v("\n   public boolean enQueue(int value) {"),t("br"),r._v("\n       // 如果已经放满了"),t("br"),r._v("\n       if (isFull()) {"),t("br"),r._v("\n           return false;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       // 如果没有放满，那么a[rear]用来存放新进来的元素"),t("br"),r._v("\n       a[rear] = value;"),t("br"),r._v("\n       // rear注意取模"),t("br"),r._v("\n       rear = (rear + 1) % capacity;"),t("br"),r._v("\n       // 已经使用的空间"),t("br"),r._v("\n       used++;"),t("br"),r._v("\n       // 存放成功!"),t("br"),r._v("\n       return true;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   public boolean deQueue() {"),t("br"),r._v("\n       // 如果是一个空队列，当然不能出队"),t("br"),r._v("\n       if (isEmpty()) {"),t("br"),r._v("\n           return false;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       // 第一个元素取出"),t("br"),r._v("\n       int ret = a[front];"),t("br"),r._v("\n       // 注意取模"),t("br"),r._v("\n       front = (front + 1) % capacity;"),t("br"),r._v("\n       // 已经存放的元素减减"),t("br"),r._v("\n       used--;"),t("br"),r._v("\n       // 取出元素成功"),t("br"),r._v("\n       return true;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   public int Front() {"),t("br"),r._v("\n       // 如果为空，不能取出队首元素"),t("br"),r._v("\n       if (isEmpty()) {"),t("br"),r._v("\n           return -1;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       // 取出队首元素"),t("br"),r._v("\n       return a[front];"),t("br"),r._v("\n   }"),t("br"),r._v("\n   public int Rear() {"),t("br"),r._v("\n       // 如果为空，不能取出队尾元素"),t("br"),r._v("\n       if (isEmpty()) {"),t("br"),r._v("\n           return -1;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       // 注意：这里不能使用rear - 1"),t("br"),r._v("\n       // 需要取模"),t("br"),r._v("\n       int tail = (rear - 1 + capacity) % capacity;"),t("br"),r._v("\n       return a[tail];"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 队列是否为空"),t("br"),r._v("\n   public boolean isEmpty() {"),t("br"),r._v("\n       return used == 0;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 队列是否满了"),t("br"),r._v("\n   public boolean isFull() {"),t("br"),r._v("\n       return used == capacity;"),t("br"),r._v("\n   }"),t("br"),r._v("\n}")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F622.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.method2.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F622.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.method2.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F622.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.method2.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("h4",{attrs:{id:"单调队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单调队列"}},[r._v("#")]),r._v(" 单调队列")]),r._v(" "),t("p",[r._v("接下来，我们看一下单调队列的实现代码。单调队列有两种，即递增队列和递减队列。由于这两种队列的代码模版非常类似，因此只需要记住其中一个就可以了，递减队列代码如下：")]),r._v(" "),t("p",[r._v("class Solution {"),t("br"),r._v("\n   // 单调队列使用双端队列来实现"),t("br"),r._v("\n   private ArrayDeque"),t("Integer",[r._v(" Q = new ArrayDeque"),t("Integer",[r._v("();"),t("br"),r._v("\n   // 入队的时候，last方向入队，但是入队的时候"),t("br"),r._v("\n   // 需要保证整个队列的数值是单调的"),t("br"),r._v("\n   // (在这个题里面我们需要是递减的)"),t("br"),r._v("\n   // 并且需要注意，这里是Q.getLast() < val"),t("br"),r._v("\n   // 如果写成Q.getLast() <= val就变成了严格单调递增"),t("br"),r._v("\n   private void push(int val) {"),t("br"),r._v("\n       while (!Q.isEmpty() && Q.getLast() < val) {"),t("br"),r._v("\n           Q.removeLast();"),t("br"),r._v("\n       }"),t("br"),r._v("\n       // 将元素入队"),t("br"),r._v("\n       Q.addLast(val);"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 出队的时候，要相等的时候才会出队"),t("br"),r._v("\n   private void pop(int val) {"),t("br"),r._v("\n       if (!Q.isEmpty() && Q.getFirst() == val) {"),t("br"),r._v("\n           Q.removeFirst();"),t("br"),r._v("\n       }"),t("br"),r._v("\n}")])],1)],1),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[r._v("此外，单调队列还可以使用“< 元素值，下标 > 同时入队和出队”的方法来实现。这两种实现本质上没有太大的区别。你可以根据你对单调队列理解程度选择一种作为做通用模板。")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F1696.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi.2.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F1696.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi.2.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F1696.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi.2.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("h4",{attrs:{id:"堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[r._v("#")]),r._v(" 堆")]),r._v(" "),t("p",[r._v("由于堆往往用来实现优先级队列，因此，这里我也整理好了堆的实现的代码：")]),r._v(" "),t("p",[r._v("class Heap {"),t("br"),r._v("\n   private int[] a = null;"),t("br"),r._v("\n   private int n = 0;"),t("br"),r._v("\n   // 下沉"),t("br"),r._v("\n   public void sink(int i) {"),t("br"),r._v("\n       int j = 0;"),t("br"),r._v("\n       int t = a[i];"),t("br"),r._v("\n       // 找到i结点的左子结点"),t("br"),r._v("\n       while ((j = (i << 1) + 1) < n) {"),t("br"),r._v("\n           // j < n - 1判断是否有右子结点"),t("br"),r._v("\n           // 如果有，并且右子结点更大，那么"),t("br"),r._v("\n           // j指向右子结点"),t("br"),r._v("\n           if (j < n - 1 && a[j] < a[j + 1]) {"),t("br"),r._v("\n               j++;"),t("br"),r._v("\n           }"),t("br"),r._v("\n           // 如果子结点比t大"),t("br"),r._v("\n           // 那么t的位置还需要往后排"),t("br"),r._v("\n           if (a[j] > t) {"),t("br"),r._v("\n               a[i] = a[j];"),t("br"),r._v("\n               i = j;"),t("br"),r._v("\n           } else {"),t("br"),r._v("\n               // 找到了t的位置"),t("br"),r._v("\n               // 此时t是大于所有的子结点的"),t("br"),r._v("\n               break;"),t("br"),r._v("\n           }"),t("br"),r._v("\n       }"),t("br"),r._v("\n       // 将t放在找到的位置那里"),t("br"),r._v("\n       a[i] = t;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 上浮"),t("br"),r._v("\n   public void swim(int i) {"),t("br"),r._v("\n       int t = a[i];"),t("br"),r._v("\n       int par = 0;"),t("br"),r._v("\n       // 如果还存在父结点"),t("br"),r._v("\n       while (i > 0 && (par = (i - 1) >> 1) != i) {"),t("br"),r._v("\n           // 如果父结点比t值小"),t("br"),r._v("\n           if (a[par] < t) {"),t("br"),r._v("\n               a[i] = a[par];"),t("br"),r._v("\n               i = par;"),t("br"),r._v("\n           } else {"),t("br"),r._v("\n               break;"),t("br"),r._v("\n           }"),t("br"),r._v("\n       }"),t("br"),r._v("\n       a[i] = t;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   public void push(int v) {"),t("br"),r._v("\n       // push是先把元素追加到数组尾巴上，然后再执行上浮操作"),t("br"),r._v("\n       a[n++] = v;"),t("br"),r._v("\n       swim(n - 1);"),t("br"),r._v("\n   }"),t("br"),r._v("\n   public int pop() {"),t("br"),r._v("\n       int ret = a[0];"),t("br"),r._v("\n       a[0] = a[--n];"),t("br"),r._v("\n       sink(0);"),t("br"),r._v("\n       return ret;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   public int size() {"),t("br"),r._v("\n       return n;"),t("br"),r._v("\n   }"),t("br"),r._v("\n}")]),r._v(" "),t("h3",{attrs:{id:"链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[r._v("#")]),r._v(" 链表")]),r._v(" "),t("p",[r._v("要想解决链表题，我们首先需要掌几种最基本的操作，如下图所示：")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/Cgp9HWCbkuKAXG9rAADVb1uk2iI400-3c3853.png",alt:"Drawing 2.png"}})]),r._v(" "),t("p",[r._v("不知道你是否还记得，我在"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6693%26fileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("《04 | 链表：如何利用“假头、新链表、双指针”解决链表题？（上）》"),t("OutboundLink")],1),r._v("中，将这几种操作整理成了一个代码模板。其核心思想就是链表的“第一斧”：假头。如下所示：")]),r._v(" "),t("p",[r._v("class MyLinkedList {"),t("br"),r._v("\n   // 实现单链表"),t("br"),r._v("\n   // 1. 假设链表中的所有节点都是 0-index的。"),t("br"),r._v("\n   class ListNode {"),t("br"),r._v("\n       public int val = 0;"),t("br"),r._v("\n       public ListNode next = null;"),t("br"),r._v("\n       public ListNode() {}"),t("br"),r._v("\n       public ListNode(int x) {"),t("br"),r._v("\n           val = x;"),t("br"),r._v("\n       }"),t("br"),r._v("\n   }"),t("br"),r._v("\n   private ListNode dummy = new ListNode();"),t("br"),r._v("\n   private ListNode tail = dummy;"),t("br"),r._v("\n   private int length = 0;"),t("br"),r._v("\n   /** Initialize your data structure here. */"),t("br"),r._v("\n   public MyLinkedList() {"),t("br"),r._v("\n   }"),t("br"),r._v("\n   private ListNode getPreNode(int index) {"),t("br"),r._v("\n       ListNode front = dummy.next;"),t("br"),r._v("\n       ListNode back = dummy;"),t("br"),r._v("\n       for (int i = 0; i < index; i++) {"),t("br"),r._v("\n           back = front;"),t("br"),r._v("\n           front = front.next;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       return back;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 获取链表中第 index 个节点的值。如果索引无效，则返回-1。"),t("br"),r._v("\n   public int get(int index) {"),t("br"),r._v("\n       if (index < 0 || index >= length) {"),t("br"),r._v("\n           return -1;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       return getPreNode(index).next.val;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 在链表的第一个元素之前添加一个值为 val 的节点。"),t("br"),r._v("\n   // 插入后，新节点将成为链表的第一个节点。"),t("br"),r._v("\n   public void addAtHead(int val) {"),t("br"),r._v("\n       ListNode p = new ListNode(val);"),t("br"),r._v("\n       p.next = dummy.next;"),t("br"),r._v("\n       dummy.next = p;"),t("br"),r._v("\n       // NOTE change tail"),t("br"),r._v("\n       if (tail == dummy) {"),t("br"),r._v("\n           tail = p;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       length++;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 将值为 val 的节点追加到链表的最后一个元素。"),t("br"),r._v("\n   public void addAtTail(int val) {"),t("br"),r._v("\n       tail.next = new ListNode(val);"),t("br"),r._v("\n       tail = tail.next;"),t("br"),r._v("\n       length++;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 在链表中的第 index 个节点之前添加值为 val  的节点。"),t("br"),r._v("\n   // 1. 如果 index 等于链表的长度，则该节点将附加到链表的末尾。"),t("br"),r._v("\n   // 2. 如果 index 大于链表长度，则不会插入节点。"),t("br"),r._v("\n   // 3. 如果index小于0，则在头部插入节点。"),t("br"),r._v("\n   public void addAtIndex(int index, int val) {"),t("br"),r._v("\n       if (index > length) {"),t("br"),r._v("\n           return;"),t("br"),r._v("\n       } else if (index == length) {"),t("br"),r._v("\n           addAtTail(val);"),t("br"),r._v("\n           return;"),t("br"),r._v("\n       } else if (index <= 0) {"),t("br"),r._v("\n           addAtHead(val);"),t("br"),r._v("\n           return;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       ListNode pre = getPreNode(index);"),t("br"),r._v("\n       ListNode p = new ListNode(val);"),t("br"),r._v("\n       p.next = pre.next;"),t("br"),r._v("\n       pre.next = p;"),t("br"),r._v("\n       // NOTE: here tail has been changed"),t("br"),r._v("\n       length++;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   // 如果索引 index 有效，则删除链表中的第 index 个节点。"),t("br"),r._v("\n   public void deleteAtIndex(int index) {"),t("br"),r._v("\n       if (index < 0 || index >= length) {"),t("br"),r._v("\n           return;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       ListNode pre = getPreNode(index);"),t("br"),r._v("\n       // NOTE: delete -> change tail"),t("br"),r._v("\n       if (tail == pre.next) {"),t("br"),r._v("\n           tail = pre;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       length--;"),t("br"),r._v("\n       pre.next = pre.next.next;"),t("br"),r._v("\n   }"),t("br"),r._v("\n}")]),r._v(" "),t("p",[r._v("此外，关于链表，我们还需要掌握另外的“两板斧”。这里我已经将知识点整理如下：")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/Cgp9HWCbku2AIQzLAAKPszYYBeI723-d1b7ce.png",alt:"Drawing 3.png"}})]),r._v(" "),t("h3",{attrs:{id:"树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[r._v("#")]),r._v(" 树")]),r._v(" "),t("p",[r._v("在"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6695%26fileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("《06 | 树：如何深度运用树的遍历？》"),t("OutboundLink")],1),r._v("中，我们深入探讨了三种遍历，并且发现只要我们掌握这三种遍历的模板代码，就能够轻松解决二叉树问题。")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/CioPOWCbkvaAMDMsAAKKPaNyzjs041-52c6e3.png",alt:"Drawing 4.png"}})]),r._v(" "),t("p",[r._v("在这一讲中，我们需要熟练掌握三种遍历的代码模板有 6 个：")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("前序遍历的递归实现与栈的实现")])]),r._v(" "),t("li",[t("p",[r._v("中序遍历的递归实现与栈的实现")])]),r._v(" "),t("li",[t("p",[r._v("后序遍历的递归实现与栈的实现")])])]),r._v(" "),t("p",[r._v("下面我们分别整理一下。")]),r._v(" "),t("h4",{attrs:{id:"前序遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前序遍历"}},[r._v("#")]),r._v(" 前序遍历")]),r._v(" "),t("p",[r._v("采用递归的前序遍历的代码如下（解析在注释里）：")]),r._v(" "),t("p",[r._v("void preOrder(TreeNode root, List"),t("Integer",[r._v(" ans) {"),t("br"),r._v("\n   // 边界处理：如果树为空，那么不需要处理"),t("br"),r._v("\n   if (root != null) {"),t("br"),r._v("\n       // 先访问根结点"),t("br"),r._v("\n       ans.add(root.val);"),t("br"),r._v("\n       // 再分别访问左子树"),t("br"),r._v("\n       preOrder(root.left, ans);"),t("br"),r._v("\n       // 再访问右子树"),t("br"),r._v("\n       preOrder(root.right, ans);"),t("br"),r._v("\n   }"),t("br"),r._v("\n}")])],1),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F05.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F05.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F05.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[r._v("使用栈来实现的前序遍历的代码如下（解析在注释里）：")]),r._v(" "),t("p",[r._v("class Solution {"),t("br"),r._v("\n   public List"),t("Integer",[r._v(" preorderTraversal(TreeNode root) {"),t("br"),r._v("\n       // 用来进行递归的栈"),t("br"),r._v("\n       Stack"),t("TreeNode",[r._v(" s = new Stack<>();"),t("br"),r._v("\n       // 用来存放遍历的结果，不算在空间复杂度里面"),t("br"),r._v("\n       List"),t("Integer",[r._v(" ans = new ArrayList<>();"),t("br"),r._v("\n       // 开始利用栈来进行遍历"),t("br"),r._v("\n       while (root != null || !s.empty()) {"),t("br"),r._v("\n           // 模拟递归的压栈过程"),t("br"),r._v("\n           while (root != null) {"),t("br"),r._v("\n               s.push(root);"),t("br"),r._v("\n               ans.add(root.val);"),t("br"),r._v("\n               root = root.left;"),t("br"),r._v("\n           }"),t("br"),r._v("\n           // 当无法压栈的时候，将root.right进行压栈"),t("br"),r._v("\n           root = s.peek();"),t("br"),r._v("\n           s.pop();"),t("br"),r._v("\n           root = root.right;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       return ans;"),t("br"),r._v("\n   }"),t("br"),r._v("\n}")])],1)],1)],1),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("h4",{attrs:{id:"中序遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#中序遍历"}},[r._v("#")]),r._v(" 中序遍历")]),r._v(" "),t("p",[r._v("采用递归的中序遍历代码如下（解析在注释里）：")]),r._v(" "),t("p",[r._v("void preOrder(TreeNode root, List"),t("Integer",[r._v(" ans) {"),t("br"),r._v("\n   if (root != null) {"),t("br"),r._v("\n       // 先遍历左子树"),t("br"),r._v("\n       preOrder(root.left, ans);"),t("br"),r._v("\n       // 然后遍历中间的根结点"),t("br"),r._v("\n       ans.add(root.val);"),t("br"),r._v("\n       // 最后遍历右子树"),t("br"),r._v("\n       preOrder(root.right, ans);"),t("br"),r._v("\n   }"),t("br"),r._v("\n}")])],1),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[r._v("采用非递归的中序代码（解析在注释里）：")]),r._v(" "),t("p",[r._v("class Solution {"),t("br"),r._v("\n   public List"),t("Integer",[r._v(" inorderTraversal(TreeNode root) {"),t("br"),r._v("\n       Stack"),t("TreeNode",[r._v(" s = new Stack<>();"),t("br"),r._v("\n       List"),t("Integer",[r._v(" ans = new ArrayList<>();"),t("br"),r._v("\n       // 注意这里的判断条件，需要root 或 stack非空"),t("br"),r._v("\n       while (root != null || !s.empty()) {"),t("br"),r._v("\n           // 往左边走，连续入栈，直到不能再走为止"),t("br"),r._v("\n           while (root != null) {"),t("br"),r._v("\n               s.push(root);"),t("br"),r._v("\n               root = root.left;"),t("br"),r._v("\n           }"),t("br"),r._v("\n           // 到达了最左边，把结点弹出来，进行遍历"),t("br"),r._v("\n           root = s.peek();"),t("br"),r._v("\n           s.pop();"),t("br"),r._v("\n           ans.add(root.val);"),t("br"),r._v("\n           // 转向右子树"),t("br"),r._v("\n           root = root.right;"),t("br"),r._v("\n       }"),t("br"),r._v("\n       // 返回遍历的结果"),t("br"),r._v("\n       return ans;"),t("br"),r._v("\n   }"),t("br"),r._v("\n}")])],1)],1)],1),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("h4",{attrs:{id:"后序遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后序遍历"}},[r._v("#")]),r._v(" 后序遍历")]),r._v(" "),t("p",[r._v("采用递归实现的后序遍历代码模板如下（解析在注释里）：")]),r._v(" "),t("p",[r._v("void postOrder(TreeNode root, List"),t("Integer",[r._v(" ans) {"),t("br"),r._v("\nif (root != null) {"),t("br"),r._v("\n   // 先遍历左子树"),t("br"),r._v("\n   postOrder(root.left, ans);"),t("br"),r._v("\n   // 最后遍历右子树"),t("br"),r._v("\n   postOrder(root.right, ans);"),t("br"),r._v("\n   // 然后遍历中间的根结点"),t("br"),r._v("\n   ans.add(root.val);"),t("br"),r._v("\n}"),t("br"),r._v("\n}")])],1),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[r._v("采用"),t("strong",[r._v("非递归的后序遍历代码如下")]),r._v("（解析在注释里）：")]),r._v(" "),t("p",[r._v("class Solution {"),t("br"),r._v("\n   public List"),t("Integer",[r._v(" postorderTraversal(TreeNode t) {"),t("br"),r._v("\n       // 存放遍历的结果"),t("br"),r._v("\n       List"),t("Integer",[r._v(" ans = new ArrayList<>();"),t("br"),r._v("\n       // pre表示遍历时前面一个已经遍历过的结点"),t("br"),r._v("\n       TreeNode pre = null;"),t("br"),r._v("\n       Stack"),t("TreeNode",[r._v(" s = new Stack<>();"),t("br"),r._v("\n       // 如果栈中还有元素，或者当前结点t非空"),t("br"),r._v("\n       while (!s.isEmpty() || t != null) {"),t("br"),r._v("\n           // 顺着左子树走，并且将所有的元素压入栈中"),t("br"),r._v("\n           while (t != null) {"),t("br"),r._v("\n               s.push(t);"),t("br"),r._v("\n               t = t.left;"),t("br"),r._v("\n           }"),t("br"),r._v("\n           // 当没有任何元素可以压栈的时候"),t("br"),r._v("\n           // 拿栈顶元素，注意这里并不将栈顶元素弹出"),t("br"),r._v("\n           // 因为在迭代时，根结点需要遍历两次，这里需要判断一下"),t("br"),r._v("\n           // 右子树是否遍历完毕"),t("br"),r._v("\n           t = s.peek();"),t("br"),r._v("\n           // 如果要遍历当前结点，需要确保右子树已经遍历完毕"),t("br"),r._v("\n           // 1. 如果当前结点右子树为空，那么右子树没有遍历的必要"),t("br"),r._v("\n           // 需要将当前结点放到ans中"),t("br"),r._v("\n           // 2. 当t.right == pre时，说明右子树已经被打印过了"),t("br"),r._v("\n           // 那么此时需要将当前结点放到ans中"),t("br"),r._v("\n           if (t.right == null || t.right == pre) {"),t("br"),r._v("\n               // 右子树已经遍历完毕，放到ans中。"),t("br"),r._v("\n               ans.add(t.val);"),t("br"),r._v("\n               // 弹栈"),t("br"),r._v("\n               s.pop();"),t("br"),r._v("\n               // 因为已经遍历了当前结点，所以需要更新pre结点"),t("br"),r._v("\n               pre = t;"),t("br"),r._v("\n               // 已经打印完毕。需要设置为空，否则下一轮循环"),t("br"),r._v("\n               // 还会遍历t的左子树。"),t("br"),r._v("\n               t = null;"),t("br"),r._v("\n           } else {"),t("br"),r._v("\n               // 第一次走到t结点，不能放到ans中，因为t的右子树还没有遍历。"),t("br"),r._v("\n               // 需要将t结点的右子树遍历"),t("br"),r._v("\n               t = t.right;"),t("br"),r._v("\n           }"),t("br"),r._v("\n       }"),t("br"),r._v("\n       return ans;"),t("br"),r._v("\n   }"),t("br"),r._v("\n}")])],1)],1)],1),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("p",[t("strong",[r._v("【面试建议")]),r._v("】在面试的时候，大部分情况都应该优先写递归的代码，除非面试官特别要求你必须使用“非递归”来实现。主要有以下几点原因：")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("递归代码更加简单，因此不容易出错；")])]),r._v(" "),t("li",[t("p",[r._v("不要为了“炫技”展示“非递归”代码；")])]),r._v(" "),t("li",[t("p",[r._v("如果我们要进行二叉树上的搜索、DP、二分等情况的时候，“非递归”的代码往往会增加代码的复杂度，面试的时候不容易完全写对。")])])]),r._v(" "),t("h3",{attrs:{id:"并查集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并查集"}},[r._v("#")]),r._v(" 并查集")]),r._v(" "),t("p",[r._v("虽然并查集的代码模板只有一个，但是涉及的知识点却不少，这里我们将重点的内容浓缩在下面这张图里：")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/Cgp9HWCbkxuAM3HPAAEzzay3PAM052-98cd71.png",alt:"Drawing 5.png"}})]),r._v(" "),t("p",[r._v("最后，我们给出并查集的代码模板如下（解析在注释里）：")]),r._v(" "),t("p",[r._v("class UF {"),t("br"),r._v("\n// 并查集数组"),t("br"),r._v("\nint[] F = null;"),t("br"),r._v("\n// 记录并查集中集合的个数"),t("br"),r._v("\nint count = 0;"),t("br"),r._v("\n// 记录集合中点的个数，比如要知道i所在集合的点有多少个: C[Find(i)]"),t("br"),r._v("\n// 注意：这里不能直接使用C[i]"),t("br"),r._v("\n// 因为只有根结点的统计才是正确的"),t("br"),r._v("\nint[] Cnt = null;"),t("br"),r._v("\n// 并查集的初始化"),t("br"),r._v("\nvoid Init(int n)"),t("br"),r._v("\n{"),t("br"),r._v("\n   F = new int[n];"),t("br"),r._v("\n   Cnt = new int[n];"),t("br"),r._v("\n   for (int i = 0; i < n; i++) {"),t("br"),r._v("\n     F[i] = i;"),t("br"),r._v("\n     Cnt[i] = 1;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   count = n;"),t("br"),r._v("\n}"),t("br"),r._v("\nint Find(int x)"),t("br"),r._v("\n{"),t("br"),r._v("\n   if (x == F[x]) {"),t("br"),r._v("\n     return x;"),t("br"),r._v("\n   }"),t("br"),r._v("\n   F[x] = Find(F[x]);"),t("br"),r._v("\n   return F[x];"),t("br"),r._v("\n}"),t("br"),r._v("\nvoid Union(int x, int y)"),t("br"),r._v("\n{"),t("br"),r._v("\n   int xpar = Find(x);"),t("br"),r._v("\n   int ypar = Find(y);"),t("br"),r._v("\n   // 将x所在集合，合并到y所在集合"),t("br"),r._v("\n   if (xpar != ypar) {"),t("br"),r._v("\n     F[xpar] = ypar;"),t("br"),r._v("\n     // y集合里面的个数要增加"),t("br"),r._v("\n     Cnt[ypar] += Cnt[xpar];"),t("br"),r._v("\n     count--;"),t("br"),r._v("\n   }"),t("br"),r._v("\n}"),t("br"),r._v("\nint Size(int i) {return Cnt[Find(i); }"),t("br"),r._v("\n}")]),r._v(" "),t("blockquote",[t("p",[r._v("代码："),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F07.UF%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.java%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F07.UF%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("C++"),t("OutboundLink")],1),r._v("/"),t("a",{attrs:{href:"https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F07.UF%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.py%3FfileGuid%3DxxQTRXtVcqtHK6j8",target:"_blank",rel:"noopener noreferrer"}},[r._v("Python"),t("OutboundLink")],1)])]),r._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[r._v("#")]),r._v(" 总结")]),r._v(" "),t("p",[r._v("在这一讲中，我们通过整理代码模板，将“第 01 讲” 到“第 07 讲”学习的所有知识点都整理好了。这样你复习起来是不是压力要小很多呢。下面我再和你分享两个代码模板的“小秘密”。")]),r._v(" "),t("h4",{attrs:{id:"模板代码要精练"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板代码要精练"}},[r._v("#")]),r._v(" 模板代码要精练")]),r._v(" "),t("p",[r._v("其实在整理模板的时候，要尽量将代码压缩得越短越好（指的并不是不换行），代码压缩得短，有以下好处：")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("如果是自己熟悉的代码，在需要记忆的情况下，越短越好记；")])]),r._v(" "),t("li",[t("p",[r._v("较短的代码可以更精练，一眼看上去没有那么大的心理压力。")])])]),r._v(" "),t("p",[r._v("比如就我自己而言，在复习并查集的代码时，就经常使用下面这段更短的代码：")]),r._v(" "),t("p",[r._v("int Find(int x) { return x == F[x] ? x : F[x] = Find(F[x]); }"),t("br"),r._v("\nvoid Union(int x, int y) {  F[find(x)] = find(y); }")]),r._v(" "),t("h4",{attrs:{id:"自己整理可复用的代码模版"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自己整理可复用的代码模版"}},[r._v("#")]),r._v(" 自己整理可复用的代码模版")]),r._v(" "),t("p",[r._v("和你分享一下自己整理的模板的好处。主要是基于以下两点原因。")]),r._v(" "),t("p",[t("strong",[r._v("1")]),r._v(". 变量的命名要有规律，而这些规律都是自己平时约定使用的，当你复习代码时会更熟练，比如：")]),r._v(" "),t("p",[r._v("1）返回值一律设置为 ans 或者 ret；")]),r._v(" "),t("p",[r._v("2）遍历下标设置为 i,j,k；")]),r._v(" "),t("p",[r._v("3）长度变量设置为 len。")]),r._v(" "),t("p",[t("strong",[r._v("2")]),r._v(". 同一个算法往往有很多种写法，自己的写法会更熟悉，而且可以不断迭代和复用。")]),r._v(" "),t("p",[r._v("所以，本讲的练习题，就是希望你能把“第 01 讲”到“第 07 讲”刷过的题的代码整理成模板。当临近面试，你只需要对着思维导图和代码模板过一下思路就可以了。")])])}),[],!1,null,null,null);t.default=a.exports}}]);