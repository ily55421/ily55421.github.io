---
title: 线性表_链表
date: 2022-12-11 20:24:49
permalink: /pages/baa6c4/
categories:
  - 算法与数据结构
  - 数据结构
tags:
  - 
---
# 线性表_链表

## 介绍

**不保存在连续存储空间中，而每一个元素里都保存了到下一个元素的地址的数据结构，我们称之为链表（Linked List）**。链表上的每一个元素又可以称它为**节点（Node）**，而链表中第一个元素，称它为**头节点（Head Node）**，最后一个元素称它为**尾节点（Tail Node）**。

![image-20221211195756837](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/19-57-56-6ddd2b757d82a08ba3c8dacb743f19f3-image-20221211195756837-84e3.png)

## 顺序访问

与数组不同的是，我们无法使用一个固定的公式来直接算出某一个特定元素的地址，从而得到那个元素的值。要找到链表中的第 N 个元素的值，我们必须要从第一个元素开始，一个一个地遍历 N 次才能找到第 N 个元素，这种访问方式，我们就称之为**顺序访问（Sequential Access）**。

## 数组与链表的性能差异

**数组和链表的对比，并不能局限于时间复杂度**。而且，在**实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。**

1. 数组的缺点是**大小固定，一经声明就要占用整块连续内存空间**。
2. **链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别**。
3. **数据拷贝的操作是非常耗时的**。
4. **如果你的代码对内存的使用非常苛刻，那数组就更适合你**。

### 空间利用率

**数组的空间利用率相当于本来需要的大小除以创建出来数组的大小**。

**链表的空间利用率上相当于值的大小除以值的大小和节点地址大小的和**。

### 时间复杂度

访问数组元素的时间复杂度是 O(1)。而因为链表顺序访问的这个特性，访问链表中第 N 个元素需要从第一个元素一直遍历到第 N 个元素，所以平均下来的时间复杂度是 O(N)。

对于数组来说，插入操作无论是发生在数组结尾还是发生在数组的中间，因为**都需要重新创建一个新的数组**出来，并**复制**一遍之前的元素到新的数组中，所以平均的时间复杂度都是 O(N)。

而对于链表来说，要是我们一直都能维护一个**尾节点**的地址的话，那么插入一个新的元素只需要 O(1) 的时间复杂度。而当插入一个元素到**链表中间**的时候，因为链表顺序访问的这个特性，我们需要先遍历一遍链表，从第一个节点开始直到第 N 个位置，然后再进行插入，所以平均下来的**时间复杂度是 O(N)**。

### 链表和数组比较

- 插入、删除、随机访问操作的时间复杂度正好相反

  | 操作     | 数组 | 链表 |
  | -------- | ---- | ---- |
  | 插入删除 | O(n) | O(1) |
  | 随机访问 | O(1) | O(n) |

- 在实际开发中，不能单纯使用复杂度分析来判断选择哪种数据结构来存储数据。数组本质上是连续的内存空间，**CPU 的缓存机制**会预先读取数组中的数据，所以访问效率更高。而链表不是连续存储的，因此 CPU 缓存没办法有效预读链表数据。

  > CPU 在从内存读取数据的时候，除了把要访问的地址的数据读取进来，还要读取附近的一个数据块并保存到 CPU 缓存中。这样下次访问内存的时候，就会先从 CPU 缓存开始查询，如果找到了就不需要从内存中读取，从而使得访问数据更快。那么对于数组来说，因为是连续的，所以加载数组中某数据的时候，会把数组中的其他数据也加载进来，从而导致数组的访问效率会更高。然而链表不是连续存储的，因此加载附近的数据块不一定会加载到链表中的数据。

- 数组的缺点是**大小固定**，那么当数组出现不够用的情况时，需要申请一个更大的内存空间，然后把数据迁移过去，这个是非常耗时的。而链表本身没有大小的限制，天然支持动态扩容。这是另一个区别。

- 链表进行频繁的插入、删除等操作会导致频繁的内存申请和释放，容易造成**内存碎片**。这对 Java 来说会导致频发的 GC（Garbage Collection，垃圾回收）。而数组相对来说没那么频繁。

## 链表的各种形式

### **单向链表**

在一个节点中既保存了我们需要的数据，也保存了指向下一个节点地址信息的链表，称之为**单向链表（Singly Linked List）**

![img](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/20-01-12-0b9f892a39ffc5e15f484c65e651cd51-Cgq2xl4AIOaASKi0AAAtOVcJUJY844-bcaa54-9807.png)

![image-20220521225254857](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/20-03-16-f0e24c5e18e3789d8c49da35a6f5af4f-image-20220521225254857-52895a-f8fc.png)

### **双向链表**

在一个节点中保存了我们需要的数据也保存了连向下一个和上一个节点地址信息的链表，称之为**双向链表（Doubly Linked List）**。和链表中尾节点的下一个节点只保存空地址一样，链表中头节点的上一个节点地址也保存着空地址

双向链表**需要额外的两个空间来存储后继结点和前驱结点的地址**。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持**双向遍历**，这样也带来了双向链表操作的灵活性。

双向链表**在某些情况下的插入、删除等操作都要比单链表简单、高效。**

 ![img](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/20-01-12-d0f086ee2b7cbe0da8849fa9700c5c76-CgpOIF4AIOaASfugAAAv9abtHU0606-80940e-db7f.png)

![image-20220521225318483](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/20-03-48-c9161256dcb7337ef2bdce46fb88f697-image-20220521225318483-412c4f-a6c5.png)

### **循环链表**

如果将尾节点指向下一个节点地址的信息更新成指向头节点的话，这样整个链表就形成了一个环，这种链表称之为**循环链表（Circular Linked List）**

**循环链表**的优点是**从链尾到链头比较方便**。当要**处理的数据具有环型结构**特点时，就特别适合采用循环链表。比如著名的[约瑟夫问题](https://gitee.com/link?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。

 ![img](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/20-01-12-0f4357cbd476884abbff516d68692040-Cgq2xl4AIOaAQyG7AAA7Z4BCAiw317-6bef9d-9544.png)

![image-20220521225311346](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/20-03-35-2497e0d7d66813bfa4ab23b5e1eb8b5a-image-20220521225311346-ea300d-3994.png)

### **双向循环链表**

![image-20220521225329426](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/20-05-13-6d1506300445374fc4e5529b530b816d-image-20220521225329426-fc4c78-9ca3.png)

## 链表代码的撰写

争哥根据自己的学习经历和工作经验，总结了几个写链表代码技巧。

### 1. 理解指针或引用的含义

C 语言有“指针”的概念，有些语言没有指针的概念，但是有“引用”的概念。**不管是指针还是引用，意思都是一样的，都是存储所指对象的内存地址。**比如 `p->next = p->next->next` 表示 p 的 next 指针存储了 p 结点的下下一个结点的内存地址。

### 2. 警惕指针丢失和内存泄漏

**写链表代码的时候，一定要注意插入或者删除的顺序，否则很容易把指针或者结点给弄丢**（这个自己确实碰到过哈哈哈哈）。比如要在 a、b 两个结点之间插入结点 x，假设当前指针 p 指向结点 a

![image-20220521225922865](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/20-10-12-bfdddffe54aa6f815ef0d744cfe6e8ba-image-20220521225922865-bd08af-5979.png)

如果使用下面这段代码则会发生指针丢失和内存泄露，因为 x->next 最终指向了自己。整个链表被断成两段，结点 b 及之后的所有结点都无法访问到了。

```c#
p->next = x;  // 将p的next指针指向x结点；
x->next = p->next;  // 将x的结点的next指针指向b结点；
```

另外，对于 C 语言来说，内存管理是由程序员负责的。如果没有手动释放结点对应的内存空间，那么会导致内存泄露。所以插入结点的时候，要注意先后顺序。对于刚才的代码，只要调换一下顺序即可。同理，删除结点对于 C 语言来说也一定要记得释放内存，否则也会出现内存泄露的问题。Java 因为有 GC 所以不需要考虑那么多。

### 3. 利用哨兵简化实现难度

**哨兵的主要作用是让代码变得统一。**因为在对链表进行插入、删除操作时，需要对插入第一个结点或者删除最后一个结点的情况进行特殊处理，如下所示。但是，这样让代码变得很繁琐、不简洁。

```c#
// 非第一个结点插入
next_node->next = p->next;
p->next = new_node;

// 第一个结点插入
if (head == null) {
    head = new_node;
}

// 删除非最后一个结点
p->next = p->next->next;

// 删除最后一个结点
if (head->next == null) {
    head = null;
}
```

为此可以引入哨兵结点，让上述代码变得统一一点。比如不管链表是不是为空，让 head 一直指向一个结点，这个结点是不带数据的，只有指针域，如下所示。这样删除最后一节点的时候和插入第一个结点的时候，操作就都变得统一了。而这个结点就是哨兵结点，我们把有哨兵结点在的链表称为带头链表。（PS：哨兵的意思让我想到了当兵的，当兵的就是要整齐统一的，因此引入哨兵之后，就变得统一了）

![image-20220521225934559](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/20-11-27-849c7cd4e05b9150cc6fdf387cb98cf2-image-20220521225934559-865a47-6476.png)

### 4. 重点留意边界条件处理

**在编写的时候一定要多注意边界条件是否考虑到了，在边界条件下能否正确运行。**边界条件，个人理解就是极端情况，比如链表为空等。那么链表代码需要检查的边界条件主要有：

- 链表为空的时候；
- 链表只包含一个结点的时候；
- 链表只包含两个结点的时候；
- 处理头结点和尾结点的时候；

> 在写任何代码的时候，一定要多想想，你的**代码在运行的时候，可能会遇到哪些边界情况或者异常情况**，针对这些情况一定要处理，这样代码才能健壮。

### 5. 举例画图，辅助思考

**举例法**和**画图法**。

**针对链表的操作，有时候光在脑子里比较难想清楚，那么可以使用举例法和画图法，这样会清晰许多。**

![image-20220521225944948](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/20-13-14-598c72c927f2203d707248cad3952660-image-20220521225944948-db2195-d2ac.png)

### 6. 多写多练，没有捷径

**自己把常见的链表操作多写几遍，出问题就一点一点调试，孰能生巧。**写链表代码是最考研逻辑思维能力的，因为链表代码到处都是指针的操作、边界条件的处理，稍有不慎就会产生 bug。链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密等（这也是面试官喜欢让人手写链表代码的原因）。那么针对链表代码，可以拿这几个链表操作练练手，一定要练啊！

- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点

> LeetCode 上的题号分别是 206，141，21，19，876。

## 应用场景

1. 使用单链表来实现 LRU 缓存淘汰算法。首先维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。

   - 如果该数据在链表中，那么删除数据对应的结点，然后将其添加到头结点的位置。
   - 如果此数据没有在链表中，那么根据缓存空间是否已满来分别进行处理。如果未满的话，那么直接插入到链表的头部；如果已满的话，那么将链表尾结点删除，将新的数据结点插入到链表的头部。

   由于不管缓存有没有满，都需要遍历一遍链表，因此这种方式实现的时间复杂度是 O(n)。

   > 另外联系生活：比如自己容量有限，清除掉自己觉得没用的东西。

2. Java 中的 LinkedHashMap 容器，使用的就是双向链表这种数据结构。

3. **空间换时间或者时间换空间的思想**：对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。比如双向链表中，就是空间换时间的思想，通过拿出另一个指针域来存储前驱结点地址，从而使得有些操作很方便。比如缓存结构中，也还是空间换时间的思想。先把数据加载到内存或者更快的缓存上，虽然带来了空间上消耗，但是速度却上去了。

4. Linux 内核很多地方也是用到了链表的。

## 总结

**缓存实际上就是利用了空间换时间的设计思想**。

**写链表代码是最考验逻辑思维能力的**

链表代码写得好坏，可以看出一个人**写代码是否够细心，考虑问题是否全面，思维是否缜密**

**和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高**。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。

总结一下自己对链表实现的一些注意事项吧。链表是无哨兵结点的，也就是 head 指针直接指向头结点的。

1. 对于插入位置已经确定了的，比如 insertToHead 或者 insertToTail 来说，需要考虑是不是第一个插入的问题；
2. 对于插入位置不确定的，比如 insertAfter insertBefore 来说，除了判断是否是空链表之外，还需要判断是否找到相关的插入的结点，以及找到的结点的位置，个人觉得分别三个，第一个结点、中间结点、尾结点；
3. 对于删除位置不确定的，几乎同上。
4. 对于查找来说，几乎也是一样的，判断是否是空链表，判断怎么样才算是找到了结点，怎样又算没找到结点。

写链表代码还是主要为了**锻炼写代码的能力，倒不是思考解决办法**。像环的检测这种解决办法我也想不出来，都是看了答案之后恍然大悟。