---
title: 贪心算法
date: 2022-12-11 23:17:24
permalink: /pages/b51c8f/
categories:
  - 算法与数据结构
  - 算法
tags:
  - 
---
# 贪心算法

## 贪心的特点

面试中考察贪心算法的题目必然具备以下**2 个特点，这里我用最通俗的话**给你描述。

### 特点 1：只选局部最优解

在求解过程中，我们可以通过**每一步都选择最优解**，最终得到整个问题的最优解。下面我们通过一个简单的题目：寻找数组中最大的数，进一步说明一下这个特点。

```JAVA
int maxValue(int[] A) {
  final int N = A == null ? 0 : A.length;
  int maxValue = Integer.MIN_VALUE; // 初始集合里面的最大值
  for (int i = 0; i < N; i++) {
    maxValue = Math.max(maxValue, A[i]);  // 迭代当前最优解
  }
  return maxValue; // 结束后，当前最优解变身全局最优解。
}
```

**首先：** 在一个初始集（这里是一个空集），设置一个初始解。在这里，我们设置为 Integer.MIN_VALUE。

**迭代**：当有新元素进来的时候，我们需要迭代当前最优解。迭代后的最优解是已知数据的最优解。

**答案**：当处理完所有的数据之后，**当前最优解**立马**变身全局最优解**。

###  特点 2：不能“逆袭”

下面我们用一道题目说明**什么是“逆袭”**。给定如下图所示的图形，从上往下走的时候，只能走到相邻格子的左边或者右边。求从顶部走到底部的最大和。

> 局部次优解不能反超，不能成为问题的最终最优解！



## 贪心算法实战分析

### 例 1：木桶装水

【**题目**】给定一个数组，表示不同的木板的高度，在装水的时候，你可以选择**两根木板**，然后装满水，在不能倾斜的情况下，里面能装多少水，应该由较短的木板决定。请问最多能装多少水？

![image-20221211225430425](https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/12/11/22-54-30-168cc807511281e3b47c8a18bc5a07a3-image-20221211225430425-7439.png)

输入：A = [1, 0, 1, 1, 0]

输出：3

解释：你可以选择 index = 0 和 index = 3，由于高度都为 1，宽度为 3，装水为 3 x 1 = 3。这样组合装的水最多。

【**分析**】在正式求解这道题目之前，我们先从一些简单的题目进行展开。比如我们非常熟悉的：求一个数组中的最大值。

```
1.max(A[i]，A[j]) 就是 [0...i] 和 [j ... N) 这两个区间里面的最大值。
2.异色区域，大于等于 A[j] 且离 j 最远的元素就是 A[i]。
3.异色区域，大于等于 A[i] 且离 i 最远的元素就是 A[j]。
```

```JAVA
int maxArea(int[] A) {
  final int N = A == null ? 0 : A.length;
  int ans = 0;
  int i = 0, j = N - 1;
  while (i < j) {
    int height = Math.min(A[i], A[j]);
    int width = j - i;
      //计算面积
    ans = Math.max(ans, height * width);
      // 双指针移动
    if (A[i] > A[j]) {
      j--;
    } else {
      i++;
    }
  }
  return ans;
}
```

### 例 2：不重叠区间

【**题目**】给定一系列区间，请你选一个子集，使得这个子集里面区间都不相互重叠，并且这个子集里面元素个数最多。不重叠的定义：区间 [3,4] 和 [4,5] 就是不重叠。 输入：A = [[1,2],[2, 3], [3,4], [1,3] 输出：3 解释：最多只能选出 3 个区间相互不重叠[1,2], [2,3], [3,4]。

【**分析**】这个问题，最后相互不重叠的区间应该是初始集合的一个子集。那么，当我们遇到一个区间的时候，应该取还是不取呢？

下面我们从“单个区间：取和不取”来展开讲解。这里我们需要稍微进行一下推导。假设：

1. 已经求解了下图中的绿色区域，并且得到了绿色区域的最优解 maxNum；
2. 接下来我们要处理红色元素（也就是单个的区间）。

（注意：下文的 maxNum 和 newMaxNum 均表示区间里面的不重合区间的最大数目，其中 newMaxNum 表示区间**范围变长**之后的**新的不重合区间**的**最大数目**）

```
这里可以分为两种情况。

Case 1：newMaxNum 不包含新来的区间（红色部分），应该直接等于旧的 maxNum

Case 2：newMaxNum一定包含新来的区间（红色部分）

如果进行迭代的话，就是：

更新后的最优解 = max（不包含红色区间 =maxNum， 一定包含红色区间的最优解）

Case 1 的值是不需要求解的。那么接下来，我们只需要看 Case 2。

这种情况又可以分为两种小情况。

Case 2.1：新来的区间与旧的任何区间都没有交集，那么 newMaxNum = maxNum + 1。

Case 2.2：新来的区间与旧的区间有交集。

Case 2.1 的值已经计算出来了，我们再来看 Case 2.2。

求解 Case 2.2，需要从区间的不重叠性出发。关于“区间不重叠”，有一个性质：

两个区间 [a, b] 和 [c,d] 不相交，只需要满足 b <= c || d <= a 就可以了。

现在，我们知道：区间的重叠只需要看两端的大小。可以将绿色区间部分排序。绿色区间集合将分为两部分：

集合 a. 与红色新进来的区间有交集（下图紫色部分）；
集合 b. 与红色新进来的区间没有交集（下图绿色部分）。
```

1. **如果新来的区间与前面的区间不重叠，那么不重叠区间数目就能增加一个。**
2. 如果你选取的区间都是不重叠的，maxEnd 是你**选中的区间**的最大 end，而**不是你查看过的区间**的最大 end。

```JAVA
int nonOverlapIntervals(int[][] A) {
    final int N = A == null ? 0 : A.length;
    // 将区间进行排序
    Arrays.sort(A, new Comparator<int[]>() {
        public int compare(int[] a, int[] b) {
            return a[1] == b[1] ? 0 : (a[1] < b[1] ? -1 : 1);
        }
    });
    // 已重叠的区间的最右端点
    int maxEnd = Integer.MIN_VALUE;
    // 不重叠 的区间的个数
    int ans = 0;
    // 开始贪心算法
    for (int i = 0; i < N; i++) {
        final int start = A[i][0];
        if (maxEnd <= start) {
            maxEnd = A[i][1];
            ans++;
        }
    }
    return ans;
}
```

### 例 3：青蛙跳

【**题目**】给定一个数组 A[]，元素 A[i] >= 0，一只青蛙站在 index = i，那它可以跳到 A[i+1], …, A[i+A[i]]（当然，它是不能跳出数组的）。那么请问这只青蛙从 index = 0 出发，能不能跳到 index = A.length - 1。

输入：A = [2, 3, 1, 2, 1]

输出：true

解释：青蛙可以这样跳，A[0] → A[1] → A[4]

【**分析**】这个问题的重点在于，**站在 index = i，那它可以跳到 [i, ..., i + A[i]]**。

因此，它表示的信息就是两点：

- 起点 i
- 终点 i + A[i]

因此只需要选择这样的区间：

- 区间的起始位置 x 一定要在 [0, i + A[i]] 范围里面，也就是要**满足相连**；
- 区间的终止位置 x + A[x] 一定要越远越好。

```JAVA
class Solution {
    public boolean canJump(int[] A) {
        final int N = A == null ? 0 : A.length;
        // 一开始，在正式开始第一次扫描之前，肯定什么元素都还没有扫描过
        // 所以之记录之前扫描位置设置为-1
        int preScanedPos = -1;
        // 根据题意
        // 当前能覆盖到数组的第0个元素。也就是当前可以够得着的元素
        int curCoveredRange = 0;
        // 如果当前
        while (curCoveredRange < N - 1) {
            int oldCoveredRange = curCoveredRange;
            // 根据优化1和优化2，我们只需要遍历
            // [preScanedPos + 1, oldCoveredRange]即可。
            // 然后不停更新curCoveredRange
            for (int i = preScanedPos + 1;
                 i <= oldCoveredRange; i++) {
                // 1. 这个区间和我们已经覆盖的范围是相连的!
                // 满足相连性
                // 2. 如果这个区间能覆盖得更远
                if (i + A[i] &gt; curCoveredRange) {
                    // 更新我们能cover的范围
                    curCoveredRange = i + A[i];
                } 
            }
            // 如果发现不能更新覆盖范围，说明已经没有变长的可能性了。
            if (oldCoveredRange == curCoveredRange) {
                return false;
            }
            // 我们记住上次已经扫描过的位置
            preScanedPos = oldCoveredRange;
        }
        return true;
    }

}
```

###  例 4： 加油站

【**题目**】巨大的环形赛道上有 N 个加油站，第 i 个加油站可以加油 G[i] 升，而从第 i 个加油站开到下一个加油站，需要 C[i] 升汽油。请你选择一个起始加油站，能够跑完环形赛道一圈。

条件：1. 注意是环形赛道；2. 汽车油箱总是足够大。

输入：G = [1,2], C=[2, 1]

输出：1

解释：从站点 0 出发，一开始只能收获 1 升油，而从 index = 0 跑到 index = 1 需要用掉 2 升汽油，所以不能从站点 0 出发。而从站点 1 出发，则可以绕着环形跑道跑一圈。

【**分析**】当拿到这个题的时候，我们首先考虑一种极端情况，那就是收入与付出不成正比。当 sum(G) < sum(C) 的时候，应该是无论如何也不可能跑一圈的。

> 当 sum(G) >= sum(C) 时，必然存在某个点出发可以绕着赛道跑一圈的情况。

```JAVA
int canCompleteCircuit(int[] G, int[] C) {
    final int N = G == null ? 0 : G.length;
    // 找一个子数组和最大的地方
    // 那么也是相当于找一个子数组和最小的地方
    long left = 0;
    int ans = 0;
    long total = 0;
    for (int i = 0; i < N; i++) {
        final int get = G[i];
        final int cost = C[i];
        total += get - cost;
        // 如果我还能开到下一站，好的，那么继续开
        if (left + get - cost >= 0) {
            left += get - cost;
        } else {
            // 如果从[ans ...i]这段区间里面的收益为负数
            left = 0;
            ans = i + 1;
        }
    }
    return total >= 0 ? ans : -1;
}
```

不过这个题还有一个比较**有趣的解法**，解题思路是这样的：

- 当总和小于 0 的时候，肯定没有解；
- 当总和大于等于 0 的时候，总是有解的，那么在选择起点的时候，可以选择一个子数组，这个子数组是数组里面的最大和，然后就以这里作为起点。（可以反证一下，如果从最大子数组和的起点出发都不能绕赛道一圈，那么其他的点就更没戏了）。

不过想要通关这种解法，需要你依次解决以下几道练习题哦。



## 练习

**练习题 1**：给定一个数组 A[]，A[i] 表示柱子的高度，宽度为一个单位。如果我们不停往里面加水，直到所有柱子之间都加满为止。请问：给定一个图形，最多能接多少单位面积的水？

输入：A = [0,1,0,2,1,0,1,3,2,1,2,1]

输出：6

解释：如图所示，最多只能接 6 个单位面积的水。蓝色部分是水，而黑色部分是柱子，数组中不同的值，由不同高度的柱子表示。



**练习题 2**：给定一系列区间，返回最少需要删除的区间数目，使得剩下的区间不重叠。

输入：A = [[1,2], [2,3], [1,4]]

输出：1

解释：这里我们选择删除 [1, 4] 剩下的区间便不再重叠。这是最少的删除区间的数目。



**练习题 3**：给定一个字符串，需要切分成尽可能多的切片，但是一个字母只能放在一个切片里面。

输入：A = "abcabdefg"

输出：5

解释：最多可以分为 ["abcab" "d" "e" "f" "g"]。你不能切成 ["a", "b", "c", "a", "b", "d", "e", "f", "g"]，在这种情况下 'a' 字母并没有处于同一个切片。



**练习题 4**：给定一系列区间，将重合的区间合并在一起。

输入：A = [[1,2], [2,3], [2,6], [7, 8]]

输出：[[1, 6], [7,8]]



**练习题 5**：问题与例 3 一样，只不过这个题：需要输出最少跳跃的次数？如果不能跳到 A.length-1，请输出 -1。

输入：A = [2, 3, 1, 2, 1]

输出：2

解释：A[0]→A[1]→A[4] 最少跳两次就可以到达最后一个下标。



接下来我们看一下：给定一系列区间，如果要完全覆盖 [start, end] 这个区间，应该如何处理呢？请看练习题 6。

**练习题 6**：一个大门安装了好几个摄像头，每个摄像头会录下一段时间的视频（假设起始时间与结束时间都是一个整数，可能为负数）。如果想找到 [0, T] 时间段的视频，请问最少需要提取几个摄像头的视频？如果不能得到 [0, T] 这个时间段的视频，输出 -1。

输入：[[1,2], [0,2], [0,1], [2,3], [2,6], [3,8]], T = 5

输出：2

解释：只需要用 [0, 2]，[2,6] 就可以完全覆盖 [0, 5] 这个时间段。因此，最少需要看 2 个摄像头。



**练习题 7**：给定一个数组，求这个子数组里面的最大子数组和。

输入：A = [1,-5,3,4]

输出：7

解释：最大子数组和为 [3,4]，形成的和为 7，没有比 7 更大的子数组和了。



**练习题 8**：给定一个数组，这个数组首尾成环，求这个环形数组里面的最大子数组和。

输入：A = [2, -2, -2, -2, 2]

输出：4

解释：最大子数组为首尾的 [2, 2]，形成的和为 4，没有比 4 更大的子数组和了。



**练习题 9**：同样是例题 4，你能使用我们前面提过的“**从最大子数组和的起点出发**”这种思路进行求解吗？

既然可以用练习题 8 思路解决例 4 的问题，那么肯定也可以用例 4 的思路解决练习题 8，你能想一下代码应该怎么写吗？

给定一个数组，这个数组首尾成环，求这个环形子数组里面的最大子数组和。

输入：A = [2, -2, -2, -2, 2]

输出：4

解释：最大子数组为首尾的 [2, 2]，形成的和为 4，没有比 4 更大的子数组和了。

## 总结与延伸

贪心算法是一种思路，没有模板和套路。不过经过今天的学习。可以发现，贪心算法的两个特点中，第一个特点**只选局部最优解**是比较容易做到的。但是难点在于： **次优解不能逆袭**。

往往我们要花非常多的时间证明，才能够保证次优解可以扔掉。这里面还涉及了非常多的数学思维，需要你活学活用。

作为面试官，我给你的建议是：刷贪心题目的时候，**一定要注意推导**！

如果你不会证明：“**为什么次优解可以扔掉？**”，

但知道如何进行操作，这说明你还没有真正掌握贪心这种思想。

**从我个人的学习经验来讲，不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。**