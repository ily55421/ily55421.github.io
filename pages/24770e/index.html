<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据结构模板 | ily55421</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="https://cdn.staticaly.com/gh/eryajf/tu/main/img/image_20220720_132133.ico">
    <script language="javascript" type="text/javascript" src="/js/pgmanor-self.js"></script>
    <meta name="description" content="💻学习📝记录🔗分享
学无止境是永远前进的基础，跃然纸上是对知识的总结交代，与众分享则是实现价值的最好方式。">
    <meta name="keywords" content="ily55421,golang,vue,go-web,go-admin,go-ldap-admin">
    <meta name="theme-color" content="#11a8cd">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/assets/css/0.styles.3485cdbd.css" as="style"><link rel="preload" href="/assets/js/app.22c8fc29.js" as="script"><link rel="preload" href="/assets/js/5.5ca26c73.js" as="script"><link rel="preload" href="/assets/js/17.efb08615.js" as="script"><link rel="prefetch" href="/assets/js/10.32a16328.js"><link rel="prefetch" href="/assets/js/11.51f4dee0.js"><link rel="prefetch" href="/assets/js/12.47439b7b.js"><link rel="prefetch" href="/assets/js/13.fa6da581.js"><link rel="prefetch" href="/assets/js/14.a4af8b3e.js"><link rel="prefetch" href="/assets/js/15.1bac7980.js"><link rel="prefetch" href="/assets/js/16.c546c54e.js"><link rel="prefetch" href="/assets/js/18.6df6b927.js"><link rel="prefetch" href="/assets/js/19.aa2ebc65.js"><link rel="prefetch" href="/assets/js/20.98445000.js"><link rel="prefetch" href="/assets/js/21.93b8a322.js"><link rel="prefetch" href="/assets/js/22.68ba2e87.js"><link rel="prefetch" href="/assets/js/23.7bd76e4e.js"><link rel="prefetch" href="/assets/js/24.96e0026b.js"><link rel="prefetch" href="/assets/js/25.4dce1013.js"><link rel="prefetch" href="/assets/js/26.e8042777.js"><link rel="prefetch" href="/assets/js/27.246ef2ff.js"><link rel="prefetch" href="/assets/js/28.5a5a4811.js"><link rel="prefetch" href="/assets/js/29.1c7e6118.js"><link rel="prefetch" href="/assets/js/30.5fe5643f.js"><link rel="prefetch" href="/assets/js/31.606cd6ab.js"><link rel="prefetch" href="/assets/js/32.ec6552bf.js"><link rel="prefetch" href="/assets/js/33.a5eb0319.js"><link rel="prefetch" href="/assets/js/34.41356f2c.js"><link rel="prefetch" href="/assets/js/35.016fe96b.js"><link rel="prefetch" href="/assets/js/36.900a4d73.js"><link rel="prefetch" href="/assets/js/37.7c0a48a5.js"><link rel="prefetch" href="/assets/js/38.15e06852.js"><link rel="prefetch" href="/assets/js/39.1c3f3e71.js"><link rel="prefetch" href="/assets/js/40.9cef432f.js"><link rel="prefetch" href="/assets/js/41.340db905.js"><link rel="prefetch" href="/assets/js/42.bed9cd8e.js"><link rel="prefetch" href="/assets/js/43.0788ee9b.js"><link rel="prefetch" href="/assets/js/44.66f5124b.js"><link rel="prefetch" href="/assets/js/45.7d946de3.js"><link rel="prefetch" href="/assets/js/46.5b72ffc5.js"><link rel="prefetch" href="/assets/js/47.97a6ecae.js"><link rel="prefetch" href="/assets/js/48.baef5044.js"><link rel="prefetch" href="/assets/js/49.22b10d23.js"><link rel="prefetch" href="/assets/js/50.b50c31a0.js"><link rel="prefetch" href="/assets/js/51.4ed326b4.js"><link rel="prefetch" href="/assets/js/52.49092ecf.js"><link rel="prefetch" href="/assets/js/53.2655952a.js"><link rel="prefetch" href="/assets/js/54.ddbdc86b.js"><link rel="prefetch" href="/assets/js/55.0c13bee5.js"><link rel="prefetch" href="/assets/js/56.4e415242.js"><link rel="prefetch" href="/assets/js/57.57e8a135.js"><link rel="prefetch" href="/assets/js/58.4db4d817.js"><link rel="prefetch" href="/assets/js/59.176c939b.js"><link rel="prefetch" href="/assets/js/6.3396a9ee.js"><link rel="prefetch" href="/assets/js/60.97283966.js"><link rel="prefetch" href="/assets/js/61.7464433f.js"><link rel="prefetch" href="/assets/js/62.668dc259.js"><link rel="prefetch" href="/assets/js/63.79f34040.js"><link rel="prefetch" href="/assets/js/64.7c8a5adf.js"><link rel="prefetch" href="/assets/js/65.155d461c.js"><link rel="prefetch" href="/assets/js/66.4a0b947b.js"><link rel="prefetch" href="/assets/js/67.b7b39512.js"><link rel="prefetch" href="/assets/js/68.954e1eed.js"><link rel="prefetch" href="/assets/js/69.3516eaea.js"><link rel="prefetch" href="/assets/js/7.0d4d4fc2.js"><link rel="prefetch" href="/assets/js/70.37a126ac.js"><link rel="prefetch" href="/assets/js/71.e5a9650b.js"><link rel="prefetch" href="/assets/js/72.ba0177d0.js"><link rel="prefetch" href="/assets/js/73.982ec98a.js"><link rel="prefetch" href="/assets/js/74.9196213d.js"><link rel="prefetch" href="/assets/js/75.551f8cda.js"><link rel="prefetch" href="/assets/js/76.3de1c123.js"><link rel="prefetch" href="/assets/js/77.cf3ad849.js"><link rel="prefetch" href="/assets/js/78.c715a3ce.js"><link rel="prefetch" href="/assets/js/79.69829b3f.js"><link rel="prefetch" href="/assets/js/8.70081c54.js"><link rel="prefetch" href="/assets/js/80.cfa3e4be.js"><link rel="prefetch" href="/assets/js/81.00848d13.js"><link rel="prefetch" href="/assets/js/9.6c002df9.js"><link rel="prefetch" href="/assets/js/mermaid.f2857331.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.c013cef0.js"><link rel="prefetch" href="/assets/js/vendors~mermaid.23884ed8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3485cdbd.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://cdn.staticaly.com/gh/eryajf/tu/main/img/image_20220720_132208.png" alt="ily55421" class="logo"> <span class="site-name can-hide">ily55421</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法与数据结构" class="dropdown-title"><a href="/algorithm/" class="link-title">算法与数据结构</a> <span class="title" style="display:none;">算法与数据结构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/24768e/" class="nav-link">算法</a></li><li class="dropdown-item"><!----> <a href="/pages/24770e/" aria-current="page" class="nav-link router-link-exact-active router-link-active">数据结构</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专题" class="dropdown-title"><a href="/topic/" class="link-title">专题</a> <span class="title" style="display:none;">专题</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/a4770e/" class="nav-link">专题文章</a></li><li class="dropdown-item"><!----> <a href="/pages/678015/" class="nav-link">Java系列</a></li><li class="dropdown-item"><!----> <a href="/pages/0590ad/" class="nav-link">Mysql系列</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="生活" class="dropdown-title"><a href="/life/" class="link-title">生活</a> <span class="title" style="display:none;">生活</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/bc7034/" class="nav-link">最佳实践</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程" class="dropdown-title"><a href="/code/" class="link-title">编程</a> <span class="title" style="display:none;">编程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/ace3fe/" class="nav-link">JAVA</a></li><li class="dropdown-item"><h4>JVM</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/f2e80b/" class="nav-link">Java虚拟机基本原理</a></li><li class="dropdown-subitem"><a href="/pages/bf46c5/" class="nav-link">高效编译</a></li><li class="dropdown-subitem"><a href="/pages/1261df/" class="nav-link">代码优化</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/categories/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="/message-board/" class="nav-link">留言板</a></div><div class="nav-item"><a href="https://ily55421.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  我的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com//" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法与数据结构" class="dropdown-title"><a href="/algorithm/" class="link-title">算法与数据结构</a> <span class="title" style="display:none;">算法与数据结构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/24768e/" class="nav-link">算法</a></li><li class="dropdown-item"><!----> <a href="/pages/24770e/" aria-current="page" class="nav-link router-link-exact-active router-link-active">数据结构</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专题" class="dropdown-title"><a href="/topic/" class="link-title">专题</a> <span class="title" style="display:none;">专题</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/a4770e/" class="nav-link">专题文章</a></li><li class="dropdown-item"><!----> <a href="/pages/678015/" class="nav-link">Java系列</a></li><li class="dropdown-item"><!----> <a href="/pages/0590ad/" class="nav-link">Mysql系列</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="生活" class="dropdown-title"><a href="/life/" class="link-title">生活</a> <span class="title" style="display:none;">生活</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/bc7034/" class="nav-link">最佳实践</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程" class="dropdown-title"><a href="/code/" class="link-title">编程</a> <span class="title" style="display:none;">编程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/ace3fe/" class="nav-link">JAVA</a></li><li class="dropdown-item"><h4>JVM</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/f2e80b/" class="nav-link">Java虚拟机基本原理</a></li><li class="dropdown-subitem"><a href="/pages/bf46c5/" class="nav-link">高效编译</a></li><li class="dropdown-subitem"><a href="/pages/1261df/" class="nav-link">代码优化</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/categories/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="/message-board/" class="nav-link">留言板</a></div><div class="nav-item"><a href="https://ily55421.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  我的博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com//" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>数据结构</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/24770e/" aria-current="page" class="active sidebar-link">数据结构模板</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/5e7fd1/" class="sidebar-link">前言_为什么学、是什么、怎么学</a></li><li><a href="/pages/d546bb/" class="sidebar-link">时间、空间复杂度</a></li><li><a href="/pages/906364/" class="sidebar-link">线性表_数组</a></li><li><a href="/pages/baa6c4/" class="sidebar-link">线性表_链表</a></li><li><a href="/pages/686b5e/" class="sidebar-link">线性表_栈</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/algorithm/#算法与数据结构" data-v-06225672>算法与数据结构</a></li><li data-v-06225672><a href="/algorithm/#数据结构" data-v-06225672>数据结构</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/ily55421" target="_blank" title="作者" class="beLink" data-v-06225672>ily55421</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-07-18</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">数据结构模板<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="数据结构模板"><a href="#数据结构模板" class="header-anchor">#</a> 数据结构模板</h1> <p>在这个模块，我把常见的“套路”题，帮你总结成手写代码时应该准备的各种代码模板。还会把自己压箱底的<strong>独家代码模板</strong>分享给你，利用它，我多次在 10 分钟以内拿下了算法面试。</p> <p>今天我先带你把数据结构部分做一个归纳和整理，<strong>方便你考前复习和平日积累</strong>。可以想象一下，如果在准备面试期间，你已经刷了很多题，那么在临近面试时还可以做些什么呢？</p> <ul><li><p>把所有写过的代码再看一遍？</p></li> <li><p>把前面 20 讲的内容从头到尾再复习一遍？</p></li> <li><p>还是继续刷题？</p></li></ul> <p>在我个人看来，以上这些方法都不可取，此时最行之有效的方法是将学过的知识尽可能地压缩、再压缩，最后形成模板。整理模板，有以下几个好处。</p> <ul><li><p>组合：其实大部分面试题都是一些算法模块的组合，并不需要我们真正去发明一个算法。</p></li> <li><p>速度：面试写题时速度更快，一些常用的功能性代码可以直接粘贴过去，不用在打字和调试上浪费时间。</p></li> <li><p>重点：可以在有限的时间里重点关注整理好的代码模板，告别“大海捞针”式的复习。</p></li></ul> <p>其实面试中考察的那些高频知识点，就像一块块“积木”，而面试求解过程就像“搭积木的游戏”。高效利用代码模版的技巧，能够帮助你在面试时写出更高效和 0 Bug 的代码。</p> <blockquote><p>说明：一些扩展知识点，我会通过练习题的形式给出来。</p></blockquote> <h3 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h3> <p>在<a href="https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6690%26fileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">《01 | 栈：从简单栈到单调栈，解决经典栈问题》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，我们将栈的知识总结在了下面这张知识导图中。</p> <p><img src="https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/CioPOWCbkq2AF_S-AAHp6R0E_i8993-217278.png" alt="Drawing 0.png"></p> <h4 id="简单栈的性质"><a href="#简单栈的性质" class="header-anchor">#</a> 简单栈的性质</h4> <p>后面我们又在<a href="https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6709%26fileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">《20 | 5 种解法，如何利用常量空间求解最长有效括号长度？》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的“特点 4”中，介绍了另一个栈的重点性质——<strong>括号匹配时栈的性质</strong>。我们可以用如下代码模板展示这个性质：</p> <p>int longestValidParentheses(String s) {<br>
   final int N = s == null ? 0 : s.length();<br> <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">1</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>
}<br>
​<br>
Stack&lt;Integer&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>
​<br> <span class="hljs-comment">// 最长的有效长度</span><br> <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>
​<br> <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> c = s.charAt(i);<br> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">')'</span>) {<br> <span class="hljs-comment">// 如果从[start, i]这个区间里面</span><br> <span class="hljs-comment">// 右括号已经可以匹配掉所有的左括号了</span><br> <span class="hljs-keyword">if</span> (st.isEmpty()) {<br> <span class="hljs-comment">// 问题2:更新新字符串的开头</span><br>
     start = i + <span class="hljs-number">1</span>;<br>
   } <span class="hljs-keyword">else</span> {<br>
     st.pop();<br> <span class="hljs-comment">// 注意问题1，3在这里统一处理</span><br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> base =<br>
         st.isEmpty() ? start : st.peek() + <span class="hljs-number">1</span>;<br>
     ans = Math.max(ans, i - base + <span class="hljs-number">1</span>);<br>
   }<br>
} <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* 如果字符是左括号 */</span><br>
   st.push(i);<br>
}<br>
} <span class="hljs-comment">// end for</span><br>
​<br> <span class="hljs-keyword">return</span> ans;<br>
​<br>
}<br>
}</p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F20.Braces%2F32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.stack.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F20.Braces%2F32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.stack.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F20.Braces%2F32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.stack.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>栈的模拟主要是使用其他数据结构来模拟栈的 push/pop 操作，主要涉及 3 个经典的题目，即下面的练习题 1、练习题 2 以及练习题 3。</p> <p><strong>练习题 1</strong>：请使用两个队列实现栈的 push/pop/empty/size 四种操作。</p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p><strong>练习题 2</strong>：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F946.%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F946.%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F946.%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p><strong>练习题 3</strong>：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F155.%E6%9C%80%E5%B0%8F%E6%A0%88.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F155.%E6%9C%80%E5%B0%8F%E6%A0%88.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F22.DS%2F155.%E6%9C%80%E5%B0%8F%E6%A0%88.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h4 id="单调栈"><a href="#单调栈" class="header-anchor">#</a> 单调栈</h4> <p>单调栈中经常还会用来解决这类题目：数组中元素右边第一个比元素自身小的元素的位置。</p> <p>int[] findRightSmall(int[] A) {<br>
// 结果数组<br>
int[] ans = new int[A.length];<br>
// 注意，栈中的元素记录的是下标<br>
Stack<Integer> t = new Stack();<br>
for (int i = 0; i &lt; A.length; i++) {<br>
   final int x = A[i];<br>
   // 每个元素都向左遍历栈中的元素完成消除动作<br>
   while (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {<br>
     // 消除的时候，记录一下被谁消除了<br>
     ans[t.peek()] = i;<br>
     // 消除时候，值更大的需要从栈中消失<br>
     t.pop();<br>
   }<br>
   // 剩下的入栈<br>
   t.push(i);<br>
}<br>
// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。<br>
while (!t.empty()) {<br>
   ans[t.peek()] = -1;<br>
   t.pop();<br>
}<br>
return ans;<br>
}</Integer></p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2FExample03.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2FExample03.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2FExample03.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>还有 3 类问题与上面这道题目类似，一般而言，深入理解其中一个模板即可。</p> <ul><li><p>数组中元素右边第一个比我大的元素的位置</p></li> <li><p>数组中元素左边离我最近且比我小的元素的位置</p></li> <li><p>数组中元素左边离我最近且比我大的元素的位置</p></li></ul> <h4 id="单调栈的性质"><a href="#单调栈的性质" class="header-anchor">#</a> 单调栈的性质</h4> <p>我们将单调栈的性质总结为以下两点，更详细的介绍你可以回到<a href="https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6705%26fileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">《16 | 如何利用 DP 与单调队列寻找最大矩形？》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>进行复习。</p> <ul><li><p>当单调递增栈中存放数组下标 i, j, k 时，其中 (i, k] 中的元素 &gt; A[j]；</p></li> <li><p>当单调递增栈中存放数组下标 i, j，并且当 A[k] 入栈，会把栈顶元素 A[j]“削”出栈时，其中 (j, k) 元素 &gt; A[j]。</p></li></ul> <p>我们曾经用到单调栈性质的模板代码求解最大矩形，如下所示：</p> <p>int largestRectangleArea(int[] A) {<br>
final int N = A == null ? 0 : A.length;<br>
// 虽然可以用Stack<Integer>，但是这里为了更快地操作，我们用<br>
// 数组模拟栈来运行，因为我们知道最多存放的内容实际上就是N个<br>
int top = 0;<br>
// s[top-1]表示栈顶元素<br>
int[] s = new int[N];<br>
int ans = 0;<br>
// 注意，这里我们取到了i == N<br>
// 按理说，不应该取到i == N的。但是这时候主要是为了处理这种数组<br>
// A = [1, 2, 3]<br>
// 没有任何元素会出栈。<br>
// 那么最后我们用一个0元素，把所有的元素都削出栈。<br>
// 这样代码就可以统一处理掉。<br>
for (int i = 0; i &lt;= N; i++) {<br>
   // 注意：当i == N的时候，x = -1;<br>
   // 比数组中的元素都要小。<br>
   final int x = i == N ? -1 : A[i];<br>
   while (top &gt; 0 &amp;&amp; A[s[top - 1]] &gt; x) {<br>
     // 计算以A[s[top]]的元素的高度的矩形。<br>
     final int height = A[s[--top]];<br>
     // i元素要将index = s[top-1]的元素出栈。<br>
     // 那么根据性质2/3：<br>
     // 此时A[s[top-1] .... i) 这个区间里面的元素都是<br>
     // 大于A[s[top-1]]的<br>
     final int rightPos = i;<br>
     // 这里需要使用性质1.<br>
     // 注意：当栈中一个元素都没有的时候，要取-1<br>
     final int leftPos = top &gt; 0 ? s[top - 1] : -1;<br>
     final int width = rightPos - leftPos - 1;<br>
     final int area = height * width;<br>
     ans = Math.max(ans, area);<br>
   }<br>
   s[top++] = i;<br>
}<br>
return ans;<br>
}</Integer></p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2F84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2F84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F01.Stack%2F84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="队列"><a href="#队列" class="header-anchor">#</a> 队列</h3> <p>关于队列的知识点，我们同样总结在了一张思维导图中，如下所示：</p> <p><img src="https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/CioPOWCbksmAJunlAAFTfMBlaiw597-a07e36.png" alt="Drawing 1.png"></p> <p>队列的数据结构知识点一般有 5 个：</p> <ul><li><p>FIFO 队列</p></li> <li><p>循环队列（模板）</p></li> <li><p>单调队列（模板）</p></li> <li><p>堆（模板）</p></li> <li><p>优先级队列</p></li></ul> <p>不过一般而言，需要重点掌握的数据结构的模板只有 3 个，即循环队列、单调队列以及堆。</p> <h4 id="循环队列"><a href="#循环队列" class="header-anchor">#</a> 循环队列</h4> <p>首先我们看一下使用数组来实现循环队列的写法，代码如下：</p> <p>class MyCircularQueue {<br>
   // 已经使用的元素个数<br>
   private int used = 0;<br>
   // 第一个元素所在位置<br>
   private int front = 0;<br>
   // rear是enQueue可在存放的位置<br>
   // 注意开闭原则<br>
   // [front, rear)<br>
   private int rear = 0;<br>
   // 循环队列最多可以存放的元素个数<br>
   private int capacity = 0;<br>
   // 循环队列的存储空间<br>
   private int[] a = null;<br>
   public MyCircularQueue(int k) {<br>
       // 初始化循环队列<br>
       capacity = k;<br>
       a = new int[capacity];<br>
   }<br>
   public boolean enQueue(int value) {<br>
       // 如果已经放满了<br>
       if (isFull()) {<br>
           return false;<br>
       }<br>
       // 如果没有放满，那么a[rear]用来存放新进来的元素<br>
       a[rear] = value;<br>
       // rear注意取模<br>
       rear = (rear + 1) % capacity;<br>
       // 已经使用的空间<br>
       used++;<br>
       // 存放成功!<br>
       return true;<br>
   }<br>
   public boolean deQueue() {<br>
       // 如果是一个空队列，当然不能出队<br>
       if (isEmpty()) {<br>
           return false;<br>
       }<br>
       // 第一个元素取出<br>
       int ret = a[front];<br>
       // 注意取模<br>
       front = (front + 1) % capacity;<br>
       // 已经存放的元素减减<br>
       used--;<br>
       // 取出元素成功<br>
       return true;<br>
   }<br>
   public int Front() {<br>
       // 如果为空，不能取出队首元素<br>
       if (isEmpty()) {<br>
           return -1;<br>
       }<br>
       // 取出队首元素<br>
       return a[front];<br>
   }<br>
   public int Rear() {<br>
       // 如果为空，不能取出队尾元素<br>
       if (isEmpty()) {<br>
           return -1;<br>
       }<br>
       // 注意：这里不能使用rear - 1<br>
       // 需要取模<br>
       int tail = (rear - 1 + capacity) % capacity;<br>
       return a[tail];<br>
   }<br>
   // 队列是否为空<br>
   public boolean isEmpty() {<br>
       return used == 0;<br>
   }<br>
   // 队列是否满了<br>
   public boolean isFull() {<br>
       return used == capacity;<br>
   }<br>
}</p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F622.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.method2.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F622.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.method2.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F622.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.method2.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h4 id="单调队列"><a href="#单调队列" class="header-anchor">#</a> 单调队列</h4> <p>接下来，我们看一下单调队列的实现代码。单调队列有两种，即递增队列和递减队列。由于这两种队列的代码模版非常类似，因此只需要记住其中一个就可以了，递减队列代码如下：</p> <p>class Solution {<br>
   // 单调队列使用双端队列来实现<br>
   private ArrayDeque<Integer> Q = new ArrayDeque<Integer>();<br>
   // 入队的时候，last方向入队，但是入队的时候<br>
   // 需要保证整个队列的数值是单调的<br>
   // (在这个题里面我们需要是递减的)<br>
   // 并且需要注意，这里是Q.getLast() &lt; val<br>
   // 如果写成Q.getLast() &lt;= val就变成了严格单调递增<br>
   private void push(int val) {<br>
       while (!Q.isEmpty() &amp;&amp; Q.getLast() &lt; val) {<br>
           Q.removeLast();<br>
       }<br>
       // 将元素入队<br>
       Q.addLast(val);<br>
   }<br>
   // 出队的时候，要相等的时候才会出队<br>
   private void pop(int val) {<br>
       if (!Q.isEmpty() &amp;&amp; Q.getFirst() == val) {<br>
           Q.removeFirst();<br>
       }<br>
}</Integer></Integer></p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>此外，单调队列还可以使用“&lt; 元素值，下标 &gt; 同时入队和出队”的方法来实现。这两种实现本质上没有太大的区别。你可以根据你对单调队列理解程度选择一种作为做通用模板。</p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F1696.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi.2.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F1696.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi.2.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F02.Queue%2F1696.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-vi.2.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h4 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h4> <p>由于堆往往用来实现优先级队列，因此，这里我也整理好了堆的实现的代码：</p> <p>class Heap {<br>
   private int[] a = null;<br>
   private int n = 0;<br>
   // 下沉<br>
   public void sink(int i) {<br>
       int j = 0;<br>
       int t = a[i];<br>
       // 找到i结点的左子结点<br>
       while ((j = (i &lt;&lt; 1) + 1) &lt; n) {<br>
           // j &lt; n - 1判断是否有右子结点<br>
           // 如果有，并且右子结点更大，那么<br>
           // j指向右子结点<br>
           if (j &lt; n - 1 &amp;&amp; a[j] &lt; a[j + 1]) {<br>
               j++;<br>
           }<br>
           // 如果子结点比t大<br>
           // 那么t的位置还需要往后排<br>
           if (a[j] &gt; t) {<br>
               a[i] = a[j];<br>
               i = j;<br>
           } else {<br>
               // 找到了t的位置<br>
               // 此时t是大于所有的子结点的<br>
               break;<br>
           }<br>
       }<br>
       // 将t放在找到的位置那里<br>
       a[i] = t;<br>
   }<br>
   // 上浮<br>
   public void swim(int i) {<br>
       int t = a[i];<br>
       int par = 0;<br>
       // 如果还存在父结点<br>
       while (i &gt; 0 &amp;&amp; (par = (i - 1) &gt;&gt; 1) != i) {<br>
           // 如果父结点比t值小<br>
           if (a[par] &lt; t) {<br>
               a[i] = a[par];<br>
               i = par;<br>
           } else {<br>
               break;<br>
           }<br>
       }<br>
       a[i] = t;<br>
   }<br>
   public void push(int v) {<br>
       // push是先把元素追加到数组尾巴上，然后再执行上浮操作<br>
       a[n++] = v;<br>
       swim(n - 1);<br>
   }<br>
   public int pop() {<br>
       int ret = a[0];<br>
       a[0] = a[--n];<br>
       sink(0);<br>
       return ret;<br>
   }<br>
   public int size() {<br>
       return n;<br>
   }<br>
}</p> <h3 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h3> <p>要想解决链表题，我们首先需要掌几种最基本的操作，如下图所示：</p> <p><img src="https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/Cgp9HWCbkuKAXG9rAADVb1uk2iI400-3c3853.png" alt="Drawing 2.png"></p> <p>不知道你是否还记得，我在<a href="https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6693%26fileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">《04 | 链表：如何利用“假头、新链表、双指针”解决链表题？（上）》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，将这几种操作整理成了一个代码模板。其核心思想就是链表的“第一斧”：假头。如下所示：</p> <p>class MyLinkedList {<br>
   // 实现单链表<br>
   // 1. 假设链表中的所有节点都是 0-index的。<br>
   class ListNode {<br>
       public int val = 0;<br>
       public ListNode next = null;<br>
       public ListNode() {}<br>
       public ListNode(int x) {<br>
           val = x;<br>
       }<br>
   }<br>
   private ListNode dummy = new ListNode();<br>
   private ListNode tail = dummy;<br>
   private int length = 0;<br>
   /** Initialize your data structure here. */<br>
   public MyLinkedList() {<br>
   }<br>
   private ListNode getPreNode(int index) {<br>
       ListNode front = dummy.next;<br>
       ListNode back = dummy;<br>
       for (int i = 0; i &lt; index; i++) {<br>
           back = front;<br>
           front = front.next;<br>
       }<br>
       return back;<br>
   }<br>
   // 获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>
   public int get(int index) {<br>
       if (index &lt; 0 || index &gt;= length) {<br>
           return -1;<br>
       }<br>
       return getPreNode(index).next.val;<br>
   }<br>
   // 在链表的第一个元素之前添加一个值为 val 的节点。<br>
   // 插入后，新节点将成为链表的第一个节点。<br>
   public void addAtHead(int val) {<br>
       ListNode p = new ListNode(val);<br>
       p.next = dummy.next;<br>
       dummy.next = p;<br>
       // NOTE change tail<br>
       if (tail == dummy) {<br>
           tail = p;<br>
       }<br>
       length++;<br>
   }<br>
   // 将值为 val 的节点追加到链表的最后一个元素。<br>
   public void addAtTail(int val) {<br>
       tail.next = new ListNode(val);<br>
       tail = tail.next;<br>
       length++;<br>
   }<br>
   // 在链表中的第 index 个节点之前添加值为 val  的节点。<br>
   // 1. 如果 index 等于链表的长度，则该节点将附加到链表的末尾。<br>
   // 2. 如果 index 大于链表长度，则不会插入节点。<br>
   // 3. 如果index小于0，则在头部插入节点。<br>
   public void addAtIndex(int index, int val) {<br>
       if (index &gt; length) {<br>
           return;<br>
       } else if (index == length) {<br>
           addAtTail(val);<br>
           return;<br>
       } else if (index &lt;= 0) {<br>
           addAtHead(val);<br>
           return;<br>
       }<br>
       ListNode pre = getPreNode(index);<br>
       ListNode p = new ListNode(val);<br>
       p.next = pre.next;<br>
       pre.next = p;<br>
       // NOTE: here tail has been changed<br>
       length++;<br>
   }<br>
   // 如果索引 index 有效，则删除链表中的第 index 个节点。<br>
   public void deleteAtIndex(int index) {<br>
       if (index &lt; 0 || index &gt;= length) {<br>
           return;<br>
       }<br>
       ListNode pre = getPreNode(index);<br>
       // NOTE: delete -&gt; change tail<br>
       if (tail == pre.next) {<br>
           tail = pre;<br>
       }<br>
       length--;<br>
       pre.next = pre.next.next;<br>
   }<br>
}</p> <p>此外，关于链表，我们还需要掌握另外的“两板斧”。这里我已经将知识点整理如下：</p> <p><img src="https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/Cgp9HWCbku2AIQzLAAKPszYYBeI723-d1b7ce.png" alt="Drawing 3.png"></p> <h3 id="树"><a href="#树" class="header-anchor">#</a> 树</h3> <p>在<a href="https://gitee.com/link?target=https%3A%2F%2Fkaiwu.lagou.com%2Fcourse%2FcourseInfo.htm%3FcourseId%3D685%23%2Fdetail%2Fpc%3Fid%3D6695%26fileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">《06 | 树：如何深度运用树的遍历？》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，我们深入探讨了三种遍历，并且发现只要我们掌握这三种遍历的模板代码，就能够轻松解决二叉树问题。</p> <p><img src="https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/CioPOWCbkvaAMDMsAAKKPaNyzjs041-52c6e3.png" alt="Drawing 4.png"></p> <p>在这一讲中，我们需要熟练掌握三种遍历的代码模板有 6 个：</p> <ul><li><p>前序遍历的递归实现与栈的实现</p></li> <li><p>中序遍历的递归实现与栈的实现</p></li> <li><p>后序遍历的递归实现与栈的实现</p></li></ul> <p>下面我们分别整理一下。</p> <h4 id="前序遍历"><a href="#前序遍历" class="header-anchor">#</a> 前序遍历</h4> <p>采用递归的前序遍历的代码如下（解析在注释里）：</p> <p>void preOrder(TreeNode root, List<Integer> ans) {<br>
   // 边界处理：如果树为空，那么不需要处理<br>
   if (root != null) {<br>
       // 先访问根结点<br>
       ans.add(root.val);<br>
       // 再分别访问左子树<br>
       preOrder(root.left, ans);<br>
       // 再访问右子树<br>
       preOrder(root.right, ans);<br>
   }<br>
}</Integer></p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F05.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F05.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F05.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>使用栈来实现的前序遍历的代码如下（解析在注释里）：</p> <p>class Solution {<br>
   public List<Integer> preorderTraversal(TreeNode root) {<br>
       // 用来进行递归的栈<br>
       Stack<TreeNode> s = new Stack&lt;&gt;();<br>
       // 用来存放遍历的结果，不算在空间复杂度里面<br>
       List<Integer> ans = new ArrayList&lt;&gt;();<br>
       // 开始利用栈来进行遍历<br>
       while (root != null || !s.empty()) {<br>
           // 模拟递归的压栈过程<br>
           while (root != null) {<br>
               s.push(root);<br>
               ans.add(root.val);<br>
               root = root.left;<br>
           }<br>
           // 当无法压栈的时候，将root.right进行压栈<br>
           root = s.peek();<br>
           s.pop();<br>
           root = root.right;<br>
       }<br>
       return ans;<br>
   }<br>
}</Integer></TreeNode></Integer></p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h4 id="中序遍历"><a href="#中序遍历" class="header-anchor">#</a> 中序遍历</h4> <p>采用递归的中序遍历代码如下（解析在注释里）：</p> <p>void preOrder(TreeNode root, List<Integer> ans) {<br>
   if (root != null) {<br>
       // 先遍历左子树<br>
       preOrder(root.left, ans);<br>
       // 然后遍历中间的根结点<br>
       ans.add(root.val);<br>
       // 最后遍历右子树<br>
       preOrder(root.right, ans);<br>
   }<br>
}</Integer></p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>采用非递归的中序代码（解析在注释里）：</p> <p>class Solution {<br>
   public List<Integer> inorderTraversal(TreeNode root) {<br>
       Stack<TreeNode> s = new Stack&lt;&gt;();<br>
       List<Integer> ans = new ArrayList&lt;&gt;();<br>
       // 注意这里的判断条件，需要root 或 stack非空<br>
       while (root != null || !s.empty()) {<br>
           // 往左边走，连续入栈，直到不能再走为止<br>
           while (root != null) {<br>
               s.push(root);<br>
               root = root.left;<br>
           }<br>
           // 到达了最左边，把结点弹出来，进行遍历<br>
           root = s.peek();<br>
           s.pop();<br>
           ans.add(root.val);<br>
           // 转向右子树<br>
           root = root.right;<br>
       }<br>
       // 返回遍历的结果<br>
       return ans;<br>
   }<br>
}</Integer></TreeNode></Integer></p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h4 id="后序遍历"><a href="#后序遍历" class="header-anchor">#</a> 后序遍历</h4> <p>采用递归实现的后序遍历代码模板如下（解析在注释里）：</p> <p>void postOrder(TreeNode root, List<Integer> ans) {<br>
if (root != null) {<br>
   // 先遍历左子树<br>
   postOrder(root.left, ans);<br>
   // 最后遍历右子树<br>
   postOrder(root.right, ans);<br>
   // 然后遍历中间的根结点<br>
   ans.add(root.val);<br>
}<br>
}</Integer></p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>采用<strong>非递归的后序遍历代码如下</strong>（解析在注释里）：</p> <p>class Solution {<br>
   public List<Integer> postorderTraversal(TreeNode t) {<br>
       // 存放遍历的结果<br>
       List<Integer> ans = new ArrayList&lt;&gt;();<br>
       // pre表示遍历时前面一个已经遍历过的结点<br>
       TreeNode pre = null;<br>
       Stack<TreeNode> s = new Stack&lt;&gt;();<br>
       // 如果栈中还有元素，或者当前结点t非空<br>
       while (!s.isEmpty() || t != null) {<br>
           // 顺着左子树走，并且将所有的元素压入栈中<br>
           while (t != null) {<br>
               s.push(t);<br>
               t = t.left;<br>
           }<br>
           // 当没有任何元素可以压栈的时候<br>
           // 拿栈顶元素，注意这里并不将栈顶元素弹出<br>
           // 因为在迭代时，根结点需要遍历两次，这里需要判断一下<br>
           // 右子树是否遍历完毕<br>
           t = s.peek();<br>
           // 如果要遍历当前结点，需要确保右子树已经遍历完毕<br>
           // 1. 如果当前结点右子树为空，那么右子树没有遍历的必要<br>
           // 需要将当前结点放到ans中<br>
           // 2. 当t.right == pre时，说明右子树已经被打印过了<br>
           // 那么此时需要将当前结点放到ans中<br>
           if (t.right == null || t.right == pre) {<br>
               // 右子树已经遍历完毕，放到ans中。<br>
               ans.add(t.val);<br>
               // 弹栈<br>
               s.pop();<br>
               // 因为已经遍历了当前结点，所以需要更新pre结点<br>
               pre = t;<br>
               // 已经打印完毕。需要设置为空，否则下一轮循环<br>
               // 还会遍历t的左子树。<br>
               t = null;<br>
           } else {<br>
               // 第一次走到t结点，不能放到ans中，因为t的右子树还没有遍历。<br>
               // 需要将t结点的右子树遍历<br>
               t = t.right;<br>
           }<br>
       }<br>
       return ans;<br>
   }<br>
}</TreeNode></Integer></Integer></p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F06.Tree%2F145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p><strong>【面试建议</strong>】在面试的时候，大部分情况都应该优先写递归的代码，除非面试官特别要求你必须使用“非递归”来实现。主要有以下几点原因：</p> <ul><li><p>递归代码更加简单，因此不容易出错；</p></li> <li><p>不要为了“炫技”展示“非递归”代码；</p></li> <li><p>如果我们要进行二叉树上的搜索、DP、二分等情况的时候，“非递归”的代码往往会增加代码的复杂度，面试的时候不容易完全写对。</p></li></ul> <h3 id="并查集"><a href="#并查集" class="header-anchor">#</a> 并查集</h3> <p>虽然并查集的代码模板只有一个，但是涉及的知识点却不少，这里我们将重点的内容浓缩在下面这张图里：</p> <p><img src="https://linkeq.oss-cn-chengdu.aliyuncs.com/img/2022/07/24/Cgp9HWCbkxuAM3HPAAEzzay3PAM052-98cd71.png" alt="Drawing 5.png"></p> <p>最后，我们给出并查集的代码模板如下（解析在注释里）：</p> <p>class UF {<br>
// 并查集数组<br>
int[] F = null;<br>
// 记录并查集中集合的个数<br>
int count = 0;<br>
// 记录集合中点的个数，比如要知道i所在集合的点有多少个: C[Find(i)]<br>
// 注意：这里不能直接使用C[i]<br>
// 因为只有根结点的统计才是正确的<br>
int[] Cnt = null;<br>
// 并查集的初始化<br>
void Init(int n)<br>
{<br>
   F = new int[n];<br>
   Cnt = new int[n];<br>
   for (int i = 0; i &lt; n; i++) {<br>
     F[i] = i;<br>
     Cnt[i] = 1;<br>
   }<br>
   count = n;<br>
}<br>
int Find(int x)<br>
{<br>
   if (x == F[x]) {<br>
     return x;<br>
   }<br>
   F[x] = Find(F[x]);<br>
   return F[x];<br>
}<br>
void Union(int x, int y)<br>
{<br>
   int xpar = Find(x);<br>
   int ypar = Find(y);<br>
   // 将x所在集合，合并到y所在集合<br>
   if (xpar != ypar) {<br>
     F[xpar] = ypar;<br>
     // y集合里面的个数要增加<br>
     Cnt[ypar] += Cnt[xpar];<br>
     count--;<br>
   }<br>
}<br>
int Size(int i) {return Cnt[Find(i); }<br>
}</p> <blockquote><p>代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F07.UF%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.java%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Java<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F07.UF%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.cpp%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FlagoueduCol%2FAlgorithm-Dryad%2Fblob%2Fmain%2F07.UF%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.py%3FfileGuid%3DxxQTRXtVcqtHK6j8" target="_blank" rel="noopener noreferrer">Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>在这一讲中，我们通过整理代码模板，将“第 01 讲” 到“第 07 讲”学习的所有知识点都整理好了。这样你复习起来是不是压力要小很多呢。下面我再和你分享两个代码模板的“小秘密”。</p> <h4 id="模板代码要精练"><a href="#模板代码要精练" class="header-anchor">#</a> 模板代码要精练</h4> <p>其实在整理模板的时候，要尽量将代码压缩得越短越好（指的并不是不换行），代码压缩得短，有以下好处：</p> <ul><li><p>如果是自己熟悉的代码，在需要记忆的情况下，越短越好记；</p></li> <li><p>较短的代码可以更精练，一眼看上去没有那么大的心理压力。</p></li></ul> <p>比如就我自己而言，在复习并查集的代码时，就经常使用下面这段更短的代码：</p> <p>int Find(int x) { return x == F[x] ? x : F[x] = Find(F[x]); }<br>
void Union(int x, int y) {  F[find(x)] = find(y); }</p> <h4 id="自己整理可复用的代码模版"><a href="#自己整理可复用的代码模版" class="header-anchor">#</a> 自己整理可复用的代码模版</h4> <p>和你分享一下自己整理的模板的好处。主要是基于以下两点原因。</p> <p><strong>1</strong>. 变量的命名要有规律，而这些规律都是自己平时约定使用的，当你复习代码时会更熟练，比如：</p> <p>1）返回值一律设置为 ans 或者 ret；</p> <p>2）遍历下标设置为 i,j,k；</p> <p>3）长度变量设置为 len。</p> <p><strong>2</strong>. 同一个算法往往有很多种写法，自己的写法会更熟悉，而且可以不断迭代和复用。</p> <p>所以，本讲的练习题，就是希望你能把“第 01 讲”到“第 07 讲”刷过的题的代码整理成模板。当临近面试，你只需要对着思维导图和代码模板过一下思路就可以了。</p></div></div>  <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">12/11/2022, 8:27:30 PM</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/24769e/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">算法的精进之路</div></a> <a href="/pages/5e7fd1/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">前言_为什么学、是什么、怎么学</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/24769e/" class="prev">算法的精进之路</a></span> <span class="next"><a href="/pages/5e7fd1/">前言_为什么学、是什么、怎么学</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="https://github.com/ily55421" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="mailto:ily55421@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://gitee.com/ily55421" title="Gitee" target="_blank" class="iconfont icon-gitee"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2022
    <span>ily55421 </span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.22c8fc29.js" defer></script><script src="/assets/js/5.5ca26c73.js" defer></script><script src="/assets/js/17.efb08615.js" defer></script>
  </body>
</html>
